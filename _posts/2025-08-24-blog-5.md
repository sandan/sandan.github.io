---
title: 'Propositions: Part 3'
date: 2025-08-27
permalink: /posts/2025/08/blog-post-5/
tags:
  - lean
  - logic
  - propositions
  - negation
  - contradiction
---

# Negation

Recall that a proposition can be True or False. If `p` is a proposition that evaluates to True, we often denote `¬p` to mean the proposition that evaluates to False. Alternatively, if `p` evaluates to False, then `¬p` evaluates to True. In general, when we state a proposition `p`, we assume it evaluates to True.

The negation operator (symbolized by `¬`) is a unary operator. It acts on a single proposition. We will show how the negation operator works in compound propositions. First, let's look at some examples:

| p | ¬p |
|---|---|
| The integer `m` is odd | The integer `m` is even |
| `x` is greater than zero | `x` is less than *or* equal to zero |
| `t` is in the set `S` | `t` is not a member of the set `S` |

## Working with Double Negation

In classical logic, `¬¬p` is equivalent to `p`. Here's a simple example:

```lean
example (p : Prop) (h : p) : ¬¬p := by
  push_neg
  exact h
```

The `push_neg` tactic simplifies negations, and in this case recognizes that proving `¬¬p` from `p` is straightforward.

## Negation with Conjunctions and Disjunctions

One of the most important relationships in logic involves how negation interacts with conjunctions and disjunctions. These are known as **De Morgan's Laws**:

- `¬(p ∧ q) ↔ ¬p ∨ ¬q` — "Not (p and q)" is equivalent to "Not p or not q"
- `¬(p ∨ q) ↔ ¬p ∧ ¬q` — "Not (p or q)" is equivalent to "Not p and not q"

The negation operator binds more strongly than conjunction (`∧`) or disjunction (`∨`), so `¬p ∧ q` means `(¬p) ∧ q`.

Let's prove the first De Morgan's law step by step:

```lean
-- De Morgan's Law: ¬(p ∧ q) → (¬p ∨ ¬q)
example (p q : Prop) : ¬(p ∧ q) → (¬p ∨ ¬q) := by
  intro h          -- Assume ¬(p ∧ q)
  by_cases hp : p  -- Consider whether p is true or false
  · -- Case: p is true
    right          -- Show ¬q (right side of disjunction)
    intro hq       -- To prove ¬q, assume q and derive contradiction
    apply h        -- Apply h : ¬(p ∧ q) to goal p ∧ q
    constructor
    · exact hp
    · exact hq
  · -- Case: p is false (¬p)
    left           -- Show ¬p (left side of disjunction)  
    exact hp

-- De Morgan's Law: ¬(p ∨ q) → (¬p ∧ ¬q)
example (p q : Prop) : ¬(p ∨ q) → (¬p ∧ ¬q) := by
  intro h          -- Assume ¬(p ∨ q)
  constructor
  · -- Show ¬p
    intro hp       -- Assume p, derive contradiction
    apply h        -- Apply h to goal p ∨ q
    left           -- Show p
    exact hp
  · -- Show ¬q  
    intro hq       -- Assume q, derive contradiction
    apply h        -- Apply h to goal p ∨ q
    right          -- Show q
    exact hq
```

## Contradiction and the Law of Excluded Middle

A fundamental principle in classical logic is the **Law of Excluded Middle**: every proposition is either true or its negation is true.

```lean
-- Law of Excluded Middle
theorem excluded_middle (p : Prop) : p ∨ ¬p := by
  by_cases h : p
  · -- Case: p is true
    left
    exact h
  · -- Case: p is false (¬p) 
    right
    exact h
```

This demonstrates an important proof technique: the `by_cases` tactic splits on whether a proposition is true or false, allowing us to handle all possibilities.

## Understanding Contradiction

When we have both a proposition and its negation as hypotheses, we have a **contradiction**. From a contradiction, we can prove anything:

```lean
-- If we assume both p and ¬p, we can derive p ∧ ¬p
theorem contradiction_example (p : Prop) (h1 : p) (h2 : ¬p) : p ∧ ¬p := by
  constructor
  · exact h1
  · exact h2

-- The contradiction tactic recognizes contradictory hypotheses automatically
theorem contradiction_tactic (p : Prop) (h1 : p) (h2 : ¬p) : p ∧ ¬p := by
  contradiction
```

The `contradiction` tactic is powerful — it can close any goal when contradictory hypotheses are present. This embodies the principle of *ex contradictione quodlibet* ("from contradiction, anything follows").

## Proof by Contradiction

Sometimes the most natural way to prove something is to assume it's false and derive a contradiction. The `by_contra` tactic enables this proof strategy:

```lean
-- Proof by contradiction: assume the goal is false, then derive contradiction
theorem no_contradiction (p : Prop) : ¬(p ∧ ¬p) := by
  by_contra h          -- Assume p ∧ ¬p is true
  -- h : p ∧ ¬p
  have h1 := h.left    -- Extract p
  have h2 := h.right   -- Extract ¬p  
  contradiction        -- h1 and h2 contradict each other
```

The `by_contra` tactic:
1. Assumes the negation of the goal as a new hypothesis
2. Changes the goal to `False`
3. Requires you to derive a contradiction from the new assumption

## A Glimpse into Implication

Now that we understand negation, we can explore **implication** — one of the most fundamental concepts in mathematical reasoning. An implication `p → q` means "if p then q" or "p implies q."

Surprisingly, implication can be understood in terms of disjunction and negation. The statement `p → q` is logically equivalent to `¬p ∨ q`. Think about it: "if p then q" is false only when p is true but q is false. In all other cases — when p is false (making `¬p` true) or when q is true — the implication holds.

Here's the key insight: `p → q` means "either p is false, or q is true (or both)."

```lean
-- Implication as disjunction
example (p q : Prop) : (p → q) ↔ (¬p ∨ q) := by
  tauto
```

We haven't formally introduced the **if and only if** operator (`↔`) yet, but it expresses logical equivalence — the statements on both sides have the same truth value in all cases.

This connection leads to the **contrapositive** — another powerful proof technique. The contrapositive of `p → q` is `¬q → ¬p`, and these statements are logically equivalent:

```lean
-- Proving the contrapositive manually
theorem contrapositive_manual (p q : Prop) (h : p → q) : ¬q → ¬p := by
  intro nq    -- Assume ¬q
  intro hp    -- Assume p (to prove ¬p, we show p → False)
  apply nq    -- Apply ¬q (which means q → False)
  exact h hp  -- Show q using h and hp

-- Alternative proof using contradiction
theorem contrapositive_contradiction (p q : Prop) (h : p → q) : ¬q → ¬p := by
  intro nq    -- Assume ¬q  
  intro hp    -- Assume p
  have hq := h hp    -- Derive q from p → q and p
  contradiction      -- nq and hq contradict each other
```

Lean also provides a `contrapose` tactic for this common pattern:

```lean
theorem contrapositive_tactic (p q : Prop) (h : p) : q → p := by
  contrapose
  intro np
  intro hq  
  exact np h
```

## Tautological Equivalences

Many logical relationships are **tautological equivalences** — they're true purely by virtue of logical structure, regardless of the specific propositions involved. We can use the **if and only if** (`↔`) operator to express these equivalences.

A **tautology** is an expression that's always true regardless of the truth values of its component propositions. Lean provides the powerful `tauto` tactic that can automatically prove any tautology or tautological equivalence:

```lean
-- Some important tautological equivalences
theorem double_negation (p : Prop) : ¬¬p ↔ p := by
  tauto

theorem negation_as_implication (p : Prop) : ¬p ↔ (p → False) := by
  tauto

theorem contrapositive_equivalence (p q : Prop) : (p → q) ↔ (¬q → ¬p) := by
  tauto

theorem implication_as_disjunction (p q : Prop) : (p → q) ↔ (¬p ∨ q) := by
  tauto

-- De Morgan's Laws as equivalences
theorem demorgan_and (p q : Prop) : ¬(p ∧ q) ↔ (¬p ∨ ¬q) := by
  tauto

theorem demorgan_or (p q : Prop) : ¬(p ∨ q) ↔ (¬p ∧ ¬q) := by
  tauto
```

## The Power of Tautologies

The `tauto` tactic is remarkably powerful — it can automatically prove any statement that's true purely by logical structure. This includes:

- All tautologies (statements always true)
- All contradictions (statements always false, when the goal is to prove `False`)
- All logical equivalences between tautologically equivalent statements

Here are some examples of complex tautologies:

```lean
-- Distribution laws
theorem distribute_and_over_or (p q r : Prop) : 
  p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by tauto

theorem distribute_or_over_and (p q r : Prop) : 
  p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := by tauto

-- Complex logical relationships
theorem complex_tautology (p q r : Prop) : 
  ((p → q) ∧ (q → r)) → (p → r) := by tauto
```

## Summary

In this chapter, we've explored:

- **Negation** (`¬`) as a unary operator that flips truth values
- **De Morgan's Laws** connecting negation with conjunction and disjunction  
- **The Law of Excluded Middle** as a fundamental tautology
- **Contradiction** and how it enables proving anything
- **Proof by contradiction** using the `by_contra` tactic
- **Contrapositive** as an equivalent form of implication
- **Tautological equivalences** and the power of the `tauto` tactic

These tools significantly expand our proof-writing capabilities. Whether working with direct proofs, proof by contradiction, or contrapositive arguments, understanding negation is crucial for navigating the logical landscape of mathematical reasoning.

**Practice Problems:**

Try proving these yourself using basic tactics (don't use `tauto` yet!):

```lean
example (p q : Prop) : ¬(p ∧ q) → (¬p ∨ ¬q) := by
  sorry

example (p q : Prop) : (p → q) → (¬q → ¬p) := by  
  sorry

example (p : Prop) : ¬¬p → p := by
  sorry

example (p q : Prop) : ¬(p ∨ q) → (¬p ∧ ¬q) := by
  sorry
```