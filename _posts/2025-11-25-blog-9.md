---
title: 'Quantifiers: Part 3'
date: 2025-11-25
permalink: /posts/2025/11/blog-post-8/
tags:
  - lean
  - logic
  - quantifiers
  - forall
  - exists
  - negation
---

Now that we are acquainted with the existential and universal quantifiers, we'll look at how negation interacts with quantifiers. 

## Negation over quantifiers

To understand how negation interacts with quantifiers, consider what it means to negate "for all x, P(x)". This universal statement is false when we can find at least one counterexample—that is, when there exists some x where P(x) fails. This gives us the equivalence:

`¬(∀x P(x)) ≡ ∃x ¬P(x)`

Similarly, negating "there exists x such that P(x)" means no such x exists—in other words, P fails for every x:

`¬(∃x P(x)) ≡ ∀x ¬P(x)`

### A concrete example

Consider the statement "All birds can fly" (∀x, Fly(x)). Its negation is NOT "No birds can fly". Rather, it's "At least one bird cannot fly" (∃x, ¬Fly(x)). Think of penguins or ostriches—a single counterexample is enough to disprove the universal claim!

### The connection to DeMorgan's Laws

We can also think of this through DeMorgan's Laws. To say that something holds "for all elements" means the property holds for each element: if x₁, x₂, x₃, ... are elements and property P holds for each, then P(x₁) ∧ P(x₂) ∧ P(x₃) ∧ ... must hold. By DeMorgan's law, distributing a negation across conjunctions gives us disjunctions: ¬P(x₁) ∨ ¬P(x₂) ∨ ¬P(x₃) ∨ ..., which corresponds to "there exists at least one element where P fails."

Similar reasoning applies to negating existential quantifiers. To say that some property holds for "at least one element" means P(x₁) ∨ P(x₂) ∨ P(x₃) ∨ ... must be true. By DeMorgan's Laws, distributing the negation across disjunctions gives us conjunctions: ¬P(x₁) ∧ ¬P(x₂) ∧ ¬P(x₃) ∧ ..., which corresponds to "P fails for every element."

## Negation of Universal quantifier

Let's prove the first equivalence formally in Lean:

```lean
example : ¬(∀x, P x) ↔ ∃ x, ¬P x := by
  constructor
  · -- ⊢ ¬∀x, P x → ∃ x, ¬ P x     -- We show the forward conditional.
    intro npx                      -- Suppose the negation of "for all x, P x",
    -- npx : ¬∀ x, P x
    -- ⊢ ∃ x, ¬P x                 -- then we show there exists an x, such that not P x.
    by_contra hn                   -- Suppose by way of contradiction the
                                   -- negation of "there exists an x, such that not P x".
    -- hn : ¬ ∃ x, ¬ P x
    -- ⊢ False

    have px : ∀ x, P x := by             -- First, we show for all x, P(x).
      intro x                            -- Let x be an arbitrary natural number,
      -- x : ℕ
      -- ⊢ P x                           -- then we show P x.
      by_contra hx                       -- Suppose by way of contradiction P(x) implies False,
      -- hx : ¬P x
      -- ⊢ False
      have nhn : ∃ y, ¬ P y := ⟨ x, hx ⟩ -- Then "there exists an x, such that P(x) implies False".
      -- nhn : ∃y, ¬P y
      -- ⊢ False
      exact hn nhn                       -- This contradicts our earlier hypothesis (hn).

    -- px : ∀ x, P x               -- Since we know for all x, P(x) and
    -- ⊢ False                     -- its negation (for all x , P(x) implies False),
    exact npx px                   -- we can conclude False.


  · -- ⊢ ∃x, ¬P x → ¬(∀ x, P x)    -- Next, we show the converse conditional.
    intro h                        -- Suppose there is an x, such that P(x) implies False.
    -- h : ∃ x, ¬P x
    -- ⊢ ¬ (∀x, P x)               -- Show it can't be the case that for all x, P(x) is true.
    obtain ⟨ n, hn ⟩ := h           -- Let n be a natural number such that P(n) implies False.
    -- n : ℕ
    -- hn : ¬P n
    -- ⊢ ¬∀x, P x
    intro np                       -- Suppose "for all x, P(x)" by way of contradiction.
    -- np : ∀ x, P x
    -- ⊢ False
    exact hn (np n)                -- But there exists an n such that P(n) implies False by hn and
                                   -- by the hypothesis np, P(n).
```


## Negation of Existential quantifier

Now let's prove the second equivalence:

```lean
example : ¬(∃x, P x) ↔ ∀x, ¬P x := by
  constructor
  · -- ⊢ ¬∃ x, P x → ∀ x, ¬P x     -- First, we show the forward case.
    intro h                        -- Suppose the negation of "there exists an x, such that P(x)".
    -- h : ¬∃ x, P x
    -- ⊢ ∀ x, ¬P x                 -- Then we show that for any natural x, x does not satisy P.
    intro n                        -- Let n be an arbitrary natural number.
    -- n : ℕ
    -- ⊢ ¬P n                      -- Then P(n) implies False.
    intro hn
    -- hn : P n                    -- Suppose P(n) by way of contradiction.
    -- ⊢ False
    apply h                        -- Then the contradiction reduces to showing
    -- ⊢ ∃ x, P x                  -- there is an x such that P(x) is true.
    use n                          -- But we can use n for that since we also have hn.

  · -- ⊢ ∀ x, ¬P → ¬∃ x, P x       -- Next, we show the converse.
    intro h                        -- Suppose for all x, not P(x).
    -- h : ∀ x, ¬P x
    -- ⊢ ¬∃ x, P x                 -- then we show there exists no x such that P(x).
    intro hp                       -- Suppose by way of contradiction that
    -- hp : ∃ x, P x               -- there is some x such that P(x).
    -- ⊢ False
    obtain ⟨ a, pa ⟩ := hp         -- Then let a be a natural number such that P(a).
    -- a : ℕ
    -- ha : P a
    -- ⊢ False
    have npa := h a                -- Then by our hypothesis h, not P(a) holds
    -- npa : ¬P a
    -- ⊢ False
    exact npa pa                   -- This directly contradicts the hypothesis P(a).
```

## Tautologies and lemmas

Lean's `tauto` tactic can automatically prove some tautologies involving quantifiers, but not all of them:

```lean
example : ¬(∃x, P x) ↔ ∀x, ¬P x := by
  tauto -- lean sees the tautology here

example : ¬(∀x, P x) ↔ ∃ x, ¬P x := by
  -- but not here, let's expand
  constructor
  · exact not_forall.mp -- tauto won't work here!
  · tauto
```

The reason `tauto` doesn't work for the universal quantifier case is that this equivalence requires classical logic. Constructively, we cannot prove ∃x ¬P(x) without actually producing a witness x. Fortunately, Lean provides lemmas for both cases:

```lean
example : ¬(∃x, P x) ↔ ∀x, ¬P x := by
  -- not_exists.{u_1} {α : Sort u_1} {p : α → Prop} : (¬∃ x, p x) ↔ ∀ (x : α), ¬p x
  exact not_exists -- or just re-use the lemma!

example : ¬(∀x, P x) ↔ ∃ x, ¬P x := by
  -- Classical.not_forall.{u_1} {α : Sort u_1} {p : α → Prop} : (¬∀ (x : α), p x) ↔ ∃ x, ¬p x
  exact not_forall -- or just re-use the lemma!
```

The lemmas have parameters that Lean infers from the example statement. These parameters are called implicit parameters in Lean and are given between the `{}` braces.

## De Morgan's Laws with quantifiers

Negation distributes over logical connectives inside quantifiers using De Morgan flips. Note how both the quantifier switches (∀ ↔ ∃) AND the connective flips (∧ ↔ ∨):

- ¬(∀x (P(x) ∧ Q(x))) ↔ ∃x (¬P(x) ∨ ¬Q(x))  
- ¬(∃x (P(x) ∨ Q(x))) ↔ ∀x (¬P(x) ∧ ¬Q(x))

For example, the negation of "every student is smart and hardworking" becomes "there exists a student who is either not smart or not hardworking (or both)."

## Summary

The key equivalences for negating quantifiers are:

| Original Statement | Negation |
|-------------------|----------|
| ∀x P(x) | ∃x ¬P(x) |
| ∃x P(x) | ∀x ¬P(x) |

Remember: negating a quantifier flips it (∀ becomes ∃ and vice versa) and pushes the negation inside to the predicate. This pattern, combined with De Morgan's Laws for logical connectives, gives us powerful tools for working with negated statements in formal logic.