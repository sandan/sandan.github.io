---
title: 'Quantifiers: Negation'
date: 2025-11-25
permalink: /posts/2025/11/blog-post-9/
tags:
  - lean
  - logic
  - quantifiers
  - forall
  - exists
  - negation
---

In the last two posts, we looked at the universal quantifier and the existential quantifier. Now that we are acquainted with both quantifiers, we'll look at how negation alters the quantified statements. 

# Negation over quantifiers

To understand how negation interacts with quantifiers, consider what it means to negate "for all x, P(x)". This universal statement is false when we can find at least one counterexample—that is, when there exists some x where P(x) fails. This gives us the equivalence:

`¬(∀x P(x)) ≡ ∃x ¬P(x)`

Similarly, negating "there exists x such that P(x)" means no such x exists—in other words, P fails for every x:

`¬(∃x P(x)) ≡ ∀x ¬P(x)`

## The connection to DeMorgan's Laws

We can also think of this through DeMorgan's Laws. To say that something holds "for all elements" means the property holds for each element: if `x₁, x₂, x₃, ...` are elements and property P holds for each, then `P(x₁) ∧ P(x₂) ∧ P(x₃) ∧ ...` must hold. By DeMorgan's law, distributing a negation across conjunctions gives us disjunctions: `¬P(x₁) ∨ ¬P(x₂) ∨ ¬P(x₃) ∨ ...`, which corresponds to "there exists at least one element where P fails."

Similar reasoning applies to negating existential quantifiers. To say that some property holds for "at least one element" means `P(x₁) ∨ P(x₂) ∨ P(x₃) ∨ ...` must be true. By DeMorgan's Laws, distributing the negation across disjunctions gives us conjunctions: `¬P(x₁) ∧ ¬P(x₂) ∧ ¬P(x₃) ∧ ...`, which corresponds to "P fails for every element."

# Negation of Universal quantifier

Let's prove the first equivalence formally in Lean:

```lean
example : ¬(∀x, P x) ↔ ∃ x, ¬P x := by
  constructor
  · -- ⊢ ¬∀x, P x → ∃ x, ¬ P x     -- We show the forward conditional.
    intro npx                      -- Suppose the negation of "for all x, P x",
    -- npx : ¬∀ x, P x
    -- ⊢ ∃ x, ¬P x                 -- then we show there exists an x, such that not P x.
    by_contra hn                   -- Suppose by way of contradiction the
                                   -- negation of "there exists an x, such that not P x".
    -- hn : ¬ ∃ x, ¬ P x
    -- ⊢ False

    have px : ∀ x, P x := by             -- First, we show for all x, P(x).
      intro x                            -- Let x be an arbitrary natural number,
      -- x : ℕ
      -- ⊢ P x                           -- then we show P x.
      by_contra hx                       -- Suppose by way of contradiction P(x) implies False,
      -- hx : ¬P x
      -- ⊢ False
      have nhn : ∃ y, ¬ P y := ⟨ x, hx ⟩ -- Then "there exists an x, such that P(x) implies False".
      -- nhn : ∃y, ¬P y
      -- ⊢ False
      exact hn nhn                       -- This contradicts our earlier hypothesis (hn).

    -- px : ∀ x, P x               -- Since we know for all x, P(x) and
    -- ⊢ False                     -- its negation (for all x , P(x) implies False),
    exact npx px                   -- we can conclude False.


  · -- ⊢ ∃x, ¬P x → ¬(∀ x, P x)    -- Next, we show the converse conditional.
    intro h                        -- Suppose there is an x, such that P(x) implies False.
    -- h : ∃ x, ¬P x
    -- ⊢ ¬ (∀x, P x)               -- Show it can't be the case that for all x, P(x) is true.
    obtain ⟨ n, hn ⟩ := h           -- Let n be a natural number such that P(n) implies False.
    -- n : ℕ
    -- hn : ¬P n
    -- ⊢ ¬∀x, P x
    intro np                       -- Suppose "for all x, P(x)" by way of contradiction.
    -- np : ∀ x, P x
    -- ⊢ False
    exact hn (np n)                -- But there exists an n such that P(n) implies False by hn and
                                   -- by the hypothesis np, P(n).
```

# Negation of Existential quantifier

Now let's prove the second equivalence:

```lean
example : ¬(∃x, P x) ↔ ∀x, ¬P x := by
  constructor
  · -- ⊢ ¬∃ x, P x → ∀ x, ¬P x     -- First, we show the forward case.
    intro h                        -- Suppose the negation of "there exists an x, such that P(x)".
    -- h : ¬∃ x, P x
    -- ⊢ ∀ x, ¬P x                 -- Then we show that for any natural x, x does not satisy P.
    intro n                        -- Let n be an arbitrary natural number.
    -- n : ℕ
    -- ⊢ ¬P n                      -- Then P(n) implies False.
    intro hn
    -- hn : P n                    -- Suppose P(n) by way of contradiction.
    -- ⊢ False
    apply h                        -- Then the contradiction reduces to showing
    -- ⊢ ∃ x, P x                  -- there is an x such that P(x) is true.
    use n                          -- But we can use n for that since we also have hn.

  · -- ⊢ ∀ x, ¬P → ¬∃ x, P x       -- Next, we show the converse.
    intro h                        -- Suppose for all x, not P(x).
    -- h : ∀ x, ¬P x
    -- ⊢ ¬∃ x, P x                 -- then we show there exists no x such that P(x).
    intro hp                       -- Suppose by way of contradiction that
    -- hp : ∃ x, P x               -- there is some x such that P(x).
    -- ⊢ False
    obtain ⟨ a, pa ⟩ := hp         -- Then let a be a natural number such that P(a).
    -- a : ℕ
    -- ha : P a
    -- ⊢ False
    have npa := h a                -- Then by our hypothesis h, not P(a) holds
    -- npa : ¬P a
    -- ⊢ False
    exact npa pa                   -- This directly contradicts the hypothesis P(a).
```

# Tautologies and lemmas

Lean's `tauto` tactic can automatically prove some tautologies involving quantifiers, but not all of them:

```lean
example : ¬(∃x, P x) ↔ ∀x, ¬P x := by
  tauto -- lean sees the tautology here

example : ¬(∀x, P x) ↔ ∃ x, ¬P x := by
  -- but not here, let's expand
  constructor
  · exact not_forall.mp -- tauto won't work here!
  · tauto
```

Fortunately, Lean provides lemmas for both equivalences:

```lean
example : ¬(∃x, P x) ↔ ∀x, ¬P x := by
  -- not_exists.{u_1} {α : Sort u_1} {p : α → Prop} : (¬∃ x, p x) ↔ ∀ (x : α), ¬p x
  exact not_exists -- or just re-use the lemma!

example : ¬(∀x, P x) ↔ ∃ x, ¬P x := by
  -- Classical.not_forall.{u_1} {α : Sort u_1} {p : α → Prop} : (¬∀ (x : α), p x) ↔ ∃ x, ¬p x
  exact not_forall -- or just re-use the lemma!
```

The lemmas have parameters that Lean infers from the example statement. These parameters are called implicit parameters in Lean and are given between the `{}` braces.

## De Morgan's Laws with quantifiers

We have seen in the previous examples how negation behaves on quantifiers. The quantified propositions can involve compound propositions. De Morgan's Laws apply in these cases:

- `¬(∀x, (P(x) ∧ Q(x))) ↔ ∃x, (¬P(x) ∨ ¬Q(x))`
The negation flips the universal quantifier to an existential quantifier as we've seen before and it flips the conjunction to disjunction:

```lean
example (P Q : ℕ → Prop) : ¬(∀ x, ((P x) ∧ (Q x))) ↔ ∃ x, (¬(P x)  ∨ ¬(Q x))  := by
  constructor
  · -- ⊢ ¬∀(x : ℕ), P x ∧ Q x → ∃ x, ¬P x ∨ ¬Q x
    intro h
    -- h: ¬∀(x : ℕ), P x ∧ Q x
    -- ⊢ ∃ x, ¬P x ∨ ¬Q x
    rw[not_forall] at h
    -- h : ∃ x, ¬ (P x ∧ Q x)
    obtain ⟨ a, ha ⟩ := h
    -- a : ℕ
    -- ha : ¬(P a ∧ Q a)
    rw[not_and_or] at ha
    -- ha : ¬P a ∨ ¬Q a
    use a
  · -- converse
    sorry
```
In the proof we use the `rw` tactic to re-write the hypotheses using the lemma `not_forall`. Rewriting hypotheses and goals is a very important step in proofs. We will see more instances of this tactic when we start using more lemmas.

 Rewriting allows us to obtain the instance `a`. After another rewrite using the `not_and_or` lemma, we can use `a` as a witness to finish the goal.

Now, let's look at another example. This time negating the existential quantfier and disjunction:
- `¬(∃x (P(x) ∨ Q(x))) ↔ ∀x (¬P(x) ∧ ¬Q(x))`

We proceed to prove the forward implication similarly to the previous example.
```lean
example (P Q : ℕ → Prop) : ¬(∃x, (P x ∨ Q x)) ↔ ∀x, (¬P x  ∧ ¬Q x ) := by
  constructor
  · -- ⊢ (¬ ∃ x, P x ∨ Q x) → ∀ x, ¬P x ∧ ¬ Q x
    intro h
    -- h : (¬ ∃ x, P x ∨ Q x)
    -- ⊢ ∀ x, ¬P x ∧ ¬ Q x
    rw[not_exists] at h
    -- h : ∀ x, ¬(P x ∨ Q x)
    intro n
    -- n : ℕ
    -- ⊢ ¬P n ∧ ¬Q n
    have hn := h n
    -- hn : ¬(P n ∨ Q n)
    rw[not_or] at hn
    -- hn : ¬P n ∧ ¬Q n
    exact hn
  · --converse
    sorry
```

Now that we have a handle on how negation works with quantified statements, we can start to explore mixed quantifiers in the next post. This will allow us to prove statements like:
- ∃x ∃y P(x, y)  -- "There exists an x and a y such that..."  
- ∀x ∀y P(x, y)  -- "For all x and all y..."
  
- ∃x ∀y P(x, y)  -- "There exists an x such that for all y..."
  Think: "I can find one special x that works with every y"
  
- ∀x ∃y P(x, y)  -- "For all x there exists a y..."
  Think: "For each x, I can find a y that works with it"


## Exercises

1. Prove the converse of DeMorgan's Laws with conjunction (with and without the `tauto` or `push_neg` tactics).

2. Prove the converse of DeMorgan's Laws with disjunction (with and without the `tauto` or `push_neg` tactics).