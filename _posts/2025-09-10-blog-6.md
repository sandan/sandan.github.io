---
title: 'Propositions: Part 4'
date: 2025-10-08
permalink: /posts/2025/10/blog-post-6/
tags:
  - lean
  - logic
  - propositions
  - exclusive or
  - mutual exclusion
---

In our previous discussions of disjunction, we introduced two interpretations: inclusive "or" (where both statements can be true) and exclusive "or" (where exactly one statement must be true). Today, we'll dive deep into exclusive or (XOR) and how it relates to mutual exclusivity in mathematics. For programmers, XOR is commonly denoted as `^` in languages like C/C++/Java, while in mathematical notation it's often written as `⊕`. In hardware design, it's represented by the gate symbol ⊻.

# Understanding Mutual Exclusivity

In mathematics, we often encounter properties that occur individually but cannot occur simultaneously. For example:
- A number cannot be both even and odd
- A real number being either rational or irrational
- An element cannot be both in a set and not in a set

This concept of mutual exclusivity is fundamental to mathematical reasoning. When two properties are mutually exclusive, they cannot be true at the same time - the truth of one implies the falsity of the other.

# Expressing XOR in Lean

Lean provides multiple ways to work with "exclusive or". Let's explore them:

## 1. Boolean XOR

The simplest form is the boolean `xor` function:
```lean 
#check xor -- Bool -> Bool -> Bool
The type of this function takes two Bool arguments and returns a Bool. In Lean, `True` and `False` are boolean literals.
-- Truth table:
#eval xor True True   -- false (can't both be true)
#eval xor False False -- false (can't both be false)
#eval xor True False  -- true  (exactly one is true)
#eval xor False True  -- true  (exactly one is true)
```
xor evaluates to `True` when the booleans have different values and `False` otherwise. 

## 2. Proposition XOR

For logical proofs, we need to work with Propositions. In Lean, `Xor'` is defined as follows:
```lean
Xor' (a b : Prop) : Prop
```
This is exactly what we'll need to prove statements about mutual exclusivity of propositions. Let's see how this function is expressed using compound propositions we have encountered previously.

```lean
import Mathlib.Tactic

example (p q : Prop) : Xor' p q ↔ (p ∧ ¬q) ∨ (q ∧ ¬ p) := by
  rw[Xor']
```

This definition directly captures the meaning of XOR: either `p` is true and `q` is false, OR `q` is true and `p` is false. You can compute the truth table for `(p ∧ ¬q) ∨ (q ∧ ¬p)` to convince yourself of this equivalence.

# Three Equivalent Definitions

There are multiple ways to define mutual exclusivity:

1. Direct Definition: `(p ∧ ¬q) ∨ (q ∧ ¬p)`
   - "Either p is true and q is false, or q is true and p is false"

2. Using OR and NOT-AND: `(p ∨ q) ∧ ¬(p ∧ q)`
   - "At least one is true, but not both"

We can encode this definition in Lean using the `def` keyword to define a function. Its signature is similar to `Xor'`. It takes two propositions `p` and `q` of type `Prop` and returns a `Prop`: 
```lean
def Xor'' (p q : Prop) : Prop := (p ∨ q) ∧ ¬(p ∧ q)
```

Now that we have two definitions, let's try proving their equivalence. 

**Proof Idea:** To show two definitions are equivalent, we need to prove both directions of the if-and-only-if (↔). For the forward direction, if we have `(p ∧ ¬q) ∨ (q ∧ ¬p)`, we can deduce both `p ∨ q` (since we have either p or q) and `¬(p ∧ q)` (since in both cases, one of them must be false). For the reverse direction, if we have `(p ∨ q) ∧ ¬(p ∧ q)`, we can construct the appropriate disjunct based on which of p or q is true (and we know they can't both be true).

```lean
example (p q : Prop) : Xor' p q ↔ Xor'' p q := by
  unfold Xor''              -- Let's unfold the definition of Xor'' 
  unfold Xor'               -- Let's unfold the definition of Xor'

  constructor               -- To prove iff, we consider the forward case and the converse
  · -- 1. Proving the forward case:
    -- ⊢ p ∧ ¬q ∨ q ∧ ¬p → (p ∨ q) ∧ ¬(p ∧ q)
    intro h                 -- Suppose we know Xor' p q. This implies either: 
                            -- p is true and q is false OR
                            -- q is true and p is false

    -- ⊢ (p ∨ q) ∧ ¬(p ∧ q) -- We show p or q is true but not both.
    constructor
    · -- h : p ∧ ¬q ∨ q ∧ ¬p
      -- 1a. ⊢ p ∨ q        -- Let's prove the left conjunct.
      
      cases h with            -- We will show in either case of our hypothesis h,
                              -- that either p or q is true.

      | inl hl =>             -- Suppose the left disjunct in our hypothesis h is true
      -- hl : p ∧ ¬q
      left                    -- Then we can show p
      -- ⊢ p
      exact hl.left           -- since we know p ∧ ¬q

      | inr hr =>             -- Suppose the right disjunct in our hypothesis h is true
      -- hr : q ∧ ¬p
      right                   -- Then we can show q
      -- ⊢ q
      exact hr.left           -- since we know q ∧ ¬p

    · -- h : p ∧ ¬q ∨ q ∧ ¬p
      -- 1b. ⊢ ¬(p ∧ q)     -- Now let's prove the right conjunct
      
      cases h with          -- We will show in either case of our hypothesis h,
                            -- that neither p and q are true simultaneously.

      | inl hl =>             -- Suppose the left disjunct in our hypothesis h is true
      -- hl : p ∧ ¬q
      -- ⊢ ¬(p ∧ q)
      push_neg                -- This tactic has two modes: in standard mode, 
                              -- it transforms ¬(p ∧ q) into p → ¬q,
                              -- whereas in distrib mode it produces ¬p ∨ ¬q. 
                              -- On my system, Lean is configured to use standard mode.
      -- ⊢ p → ¬q
      intro h                 -- Suppose p
      -- h : p
      -- ⊢ ¬q                 -- Show ¬q
      exact hl.right          -- this follows from the left disjunct hl

      | inr hr =>             -- Suppose the right disjunct in our hypothesis h is true 
      -- hr : q ∧ ¬p
      -- ⊢ ¬(p ∧ q)
      rw[not_and_or]          -- We use De Morgan's law
      -- ⊢ ¬p ∨ ¬q            
      left                    -- Then we can show ¬p
      -- ⊢ ¬p
      exact hr.right          -- since we know q ∧ ¬p (hr)
```

It turns out that there is a lemma built into Lean's Mathlib library that can turn the proof above into a single line:
```lean
theorem xor''_equiv (p q : Prop) : Xor' p q ↔ Xor'' p q := by
  exact xor_iff_or_and_not_and p q
```
Searching for an existing proof and re-using it has its merits. It saves time and energy. However, it can abstract away ideas or techniques that may be useful. Always be skeptical of anything handed to you on a "silver platter". Abstract away details of a proof that are not important in understanding the focal point. Leave enough detail to emphasize how you understand the proof.

Here is yet another way of expressing mutual exclusivity:
3. Using if-and-only-if: `p ↔ ¬q`
   - "p and q have different truth values"

Let's define this alternative in Lean:
```lean
def Xor''' (p q : Prop) : Prop := (p ↔ ¬q)
```

If we can show that `Xor'` is equivalent to this new definition `Xor'''`, then as a corollary, we can show `Xor'' ↔  Xor'''`.  Indeed, if we search Mathlib, we can see that we can use `xor_iff_iff_not`:

```lean
theorem xor'''_equiv (p q : Prop) : Xor' p q ↔ Xor''' p q := by
  exact xor_iff_iff_not
```

Now, to prove the corollary, we can simply use our previous two theorems:
```lean
theorem xor_equiv (p q : Prop) : Xor'' p q ↔ Xor''' p q := by
  rw[← xor''_equiv, ← xor'''_equiv]
```

These three definitions are logically equivalent, and each offers a different perspective on what XOR means.

# Symmetry

XOR is symmetric. It doesn't matter which proposition we write first:
```lean
-- symmetry
example (p q : Prop) : Xor' p q = Xor' q p := by
  exact xor_comm p q
```

# Identity
The literals `True` and `False` can also be used in place of Propositions. If we use `False` in XOR, the function simplifies to the identity function. 

**Proof Idea:** Think about what happens when we XOR with `False`. Since `False` is never true, the only way to get a true result is if p is true (similar to how 0 is the identity element for XOR in binary arithmetic). We can prove this by showing the formula reduces to p through a series of built-in lemmas in Lean:
```lean
example (p : Prop) : Xor' p False ↔ p := by
  unfold Xor'
  -- ⊢ p ∧ ¬False ∨ False ∧ ¬p ↔ p
  rw[not_false_eq_true] 
  -- ⊢ p ∧ True ∨ False ∧ ¬p ↔ p
  rw[and_true]
  --- ⊢ p ∨ False ∧ ¬p ↔ p
  rw[or_and_left]
  -- ⊢ (p ∨ False) ∧ (p ∨ ¬p) ↔ p
  rw[or_false]
  -- ⊢ p ∧ (p ∨ ¬p) ↔ p
  rw[and_or_left]
  -- ⊢ p ∧ p ∨ p ∧ ¬p ↔ p
  rw[and_self]
  -- ⊢ p ∨ p ∧ ¬p ↔ p
  rw[and_not_self_iff]
  -- ⊢ p ∨ False ↔ p
  rw[or_false]
  -- ⊢ p ↔ p (rw closes the goal)
```
Here's another simpler proof and an example of automating proofs. We covered `tauto` in our previous post:
```lean
example (p : Prop) : Xor' p False ↔ p := by
  unfold Xor'
  tauto
  ```

# Associativity

**Proof Idea:** This proof is similar to showing associativity of addition or other binary operations. We need to show that grouping operations as either `(p XOR q) XOR r` or `p XOR (q XOR r)` yields the same result. The proof relies on expanding both sides using the definition of XOR and showing they are logically equivalent. The `tauto` tactic can handle this because XOR's associativity follows from basic propositional logic.

```lean
-- Associativity of XOR: (p XOR q) XOR r ↔ p XOR (q XOR r)
theorem xor_assoc (p q r : Prop) : Xor' (Xor' p q) r ↔ Xor' p (Xor' q r) := by
  simp[Xor'] -- shorthand equivalent to rw[Xor', Xor', Xor', Xor']
  tauto
```

# Distributivity

**Proof Idea:** This proof shows how XOR distributes over AND, similar to how multiplication distributes over addition. The key insight is that when we XOR two conjunctions `(p ∧ r) XOR (q ∧ r)`, we're really comparing the p and q parts while keeping r constant. To prove this:
1. Forward direction (→): If `p XOR q` is true and r is true, then exactly one of p or q is true, and when combined with r, exactly one of `p ∧ r` or `q ∧ r` will be true.
2. Reverse direction (←): If `(p ∧ r) XOR (q ∧ r)` is true, then r must be true (since one of the conjunctions is true), and p and q must differ (since exactly one conjunction is true).

```lean
-- XOR distributes over AND
-- (p XOR q) AND r ↔ (p AND r) XOR (q AND r)
example (p q r : Prop) : Xor' p q ∧ r ↔ Xor' (p ∧ r) (q ∧ r) := by
  constructor
  · -- 1. Forward case
    -- ⊢ Xor' p q ∧ r → Xor' (p ∧ r) (q ∧ r)
    intro h                             -- Suppose h
    -- h : (Xor' p q) ∧ r
    -- ⊢ Xor' (p ∧ r) (q ∧ r)           -- then we show

    cases h.left with                   -- that we can derive the goal
                                        -- in each case of the hypothesis h.left:
                                        -- (p ∧ ¬q) ∨ (q ∧ ¬p).

    | -- h₁ : p ∧ ¬q                      -- Suppose we know p ∧ ¬q.
    inl h₁ =>
      left                                -- We show the left disjunct of Xor'.
      -- ⊢ (p ∧ r) ∧ ¬(q ∧ r)
      constructor
      · -- ⊢ p ∧ r
        constructor                       -- this follows easily from h and h₁
        · exact h₁.left
        · exact h.right
      · -- ⊢ ¬(q ∧ r)
        intro h₂                          -- to show ¬(q ∧ r), assume it by way of contradiction
        -- h₂ : q ∧ r
        -- ⊢ False
        exact h₁.right h₂.left            -- but then we have q ∧ ¬q.

    | -- h₂ : q ∧ ¬p                      -- Now, suppose we know q ∧ ¬p.
    inr h₂ =>
      right                               -- We show the right disjunct of Xor'.
      -- ⊢ (q ∧ r) ∧ ¬(p ∧ r)
      constructor
      · -- ⊢ q ∧ r                        -- this follows easily from h and h₂
        constructor
        · exact h₂.left
        · exact h.right
      · -- ⊢ ¬(p ∧ r)
        intro k                           -- to show ¬(p ∧ r), assume it by way of contradiction
        -- k : p ∧ r
        -- ⊢ False
        exact h₂.right k.left             -- but then we have ¬p ∧ p

  · -- 2. Converse case
    -- ⊢ Xor' (p ∧ r) (q ∧ r) → (Xor' p q) ∧ r
    intro h                             -- Suppose we know h.
    -- h : Xor' (p ∧ r) (q ∧ r)
    -- ⊢ Xor' p q ∧ r                   -- then we show...
    constructor
    · -- ⊢ Xor' p q                     -- Let's prove the left conjunct
      cases h with                      -- Now we show Xor' p q in each case of h,
                                        -- namely, either (p ∧ r) ∧ ¬(q ∧ r) OR
                                        -- (q ∧ r) ∧ ¬(p ∧ r).

      | -- h₁ : (p ∧ r) ∧ ¬(q ∧ r)        -- Suppose the left disjunct of h, h₁
        -- ⊢ Xor' p q                     -- Show this disjunction: (p ∧ ¬q) ∨ (¬p ∧ q).
      inl h₁ =>
        left                              -- We choose to show (p ∧ ¬q).
        -- ⊢ p ∧ ¬q
        constructor
        · -- ⊢ p
          exact h₁.left.left               -- We know p from h₁
        · -- ⊢ ¬q
          intro hq                         -- to show ¬q, assume q by way of contradiction
          -- hq : q
          -- ⊢ False
          exact h₁.right ⟨hq, h₁.left.right⟩-- then ¬(q ∧ r) and (q ∧ r)
                                           -- using implication,
                                           -- (q ∧ r) → False
                                           -- and we know (q ∧ r)

      | -- h₁ : (q ∧ r) ∧ ¬(p ∧ r)         -- Now, suppose the right disjunct of h, h₁
        -- ⊢ Xor' p q                      -- Show this disjunction: (p ∧ ¬q) ∨ (¬p ∧ q).
      inr h₁ =>
        right                              -- We choose to show (¬p ∧ q)
        -- ⊢ q ∧ ¬p                        -- or equivalently, q ∧ ¬p (conjunction commutes)
        constructor
        · -- ⊢ q
          exact h₁.left.left                -- We know q from h₁
        · -- ⊢ ¬p
          intro hp                          -- to show ¬p, assume p by way of contradiction
          -- hp : p
          -- ⊢ False
          exact h₁.right ⟨hp, h₁.left.right⟩ -- then ¬(p ∧ r) and (p ∧ r)

    · -- h : Xor' (p ∧ r) (q ∧ r)         -- Let's prove the right conjunct.
      -- ⊢ r                              -- Now we show that in each case of h,
      cases h with                        -- we can derive r.
      | -- h₁ : (p ∧ r) ∧ ¬(q ∧ r)
      inl h₁ =>
        exact h₁.left.right               -- r follows easily from h₁
      | -- h₁ : (q ∧ r) ∧ ¬(p ∧ r)
      inr h₂ =>
        exact h₂.left.right               -- ... and from h₂
```

# Practice Problems

Try out some of these exercises. Here are some hints for approaching each problem:

1. For XOR with True, think about how this acts as a NOT operation (similar to XOR with 1 in binary arithmetic).
2. For mutual exclusion, consider why XOR naturally implies the impossibility of both being true.
3. For self-XOR, consider what it means for a proposition to be different from itself (like how n XOR n = 0 in binary).
4. For the XOR chain, think about transitivity and how XOR operations combine (similar to how XOR chains work in cryptography).

```lean
example (p : Prop) : Xor' p True ↔ ¬p := by
  sorry

example (p q : Prop) : Xor' p q → ¬(p ∧ q) := by
  sorry

example (p : Prop) : Xor' p p → False := by
  sorry

example (p q r : Prop) : Xor' p q ∧ Xor' q r → (Xor' (¬p) r) := by
  sorry
```

