---
title: 'Propositions: Part 4'
date: 2025-10-08
permalink: /posts/2025/10/blog-post-6/
tags:
  - lean
  - logic
  - propositions
  - exclusive or
  - mutual exclusion
---

In our previous discussions of disjunction, we introduced two interpretations: inclusive "or" (where both statements can be true) and exclusive "or" (where exactly one statement must be true). Today, we'll dive deep into exclusive or (XOR) and how it relates to mutual exclusivity in mathematics. The mutual exclusion operator is sometimes denoted with `p ^ q` or `p xor q`. As we will see in Lean, we use pre-order notation.

# Understanding Mutual Exclusivity

In mathematics, we often encounter properties that occur individually but cannot occur simultaneously. For example:
- A number cannot be both even and odd
- A real number being either rational or irrational
- An element cannot be both in a set and not in a set

This concept of mutual exclusivity is fundamental to mathematical reasoning. When two properties are mutually exclusive, they cannot be true at the same time - the truth of one implies the falsity of the other.

# Expressing XOR in Lean

Lean provides multiple ways to work with "exclusive or". Let's explore them:

## 1. Boolean XOR

The simplest form is the boolean `xor` function:
```lean 
#check xor -- Bool -> Bool -> Bool
The type of this function takes two Bool arguments and returns a Bool. In Lean, `True` and `False` are boolean literals.
-- Truth table:
#eval xor True True   -- false (can't both be true)
#eval xor False False -- false (can't both be false)
#eval xor True False  -- true  (exactly one is true)
#eval xor False True  -- true  (exactly one is true)
```
xor evaluates to `True` when the booleans have different values and `False` otherwise. 

## 2. Proposition-Level XOR

For logical proofs, we need to work with Propositions. In Lean, `Xor'` is defined as follows
```lean
Xor' (a b : Prop) : Prop
```
This is exactly what we'll need to prove statements about mutual exclusivity of propositions. Let's see how this function is expressed using compound propositions we have encountered previously.

```lean
import Mathlib.Tactic

example (p q : Prop) : Xor' p q ↔ (p ∧ ¬q) ∨ (q ∧ ¬ p) := by
  rw[Xor']
```

This definition directly captures the meaning of XOR: either `p` is true and `q` is false, OR `q` is true and `p` is false. You can compute the truth table for `(p ∧ ¬q) ∨ (q ∧ ¬p)` to convince yourself of this equivalence.

# Three Equivalent Definitions

There are multiple ways to define mutual exclusivity:

1. Direct Definition: `(p ∧ ¬q) ∨ (q ∧ ¬p)`
   - "Either p is true and q is false, or q is true and p is false"

2. Using OR and NOT-AND: `(p ∨ q) ∧ ¬(p ∧ q)`
   - "At least one is true, but not both"

We can encode this definition in Lean using the `def` keyword to define a function. Its signature is similar to `Xor'`. It takes two propositions `p` and `q` of type `Prop` and returns a `Prop`: 
```lean
def Xor'' (p q : Prop) : Prop := (p ∨ q) ∧ ¬(p ∧ q)
```

Now that we have two definitions, let's try proving their equivalence. 

```lean
example (p q : Prop) : Xor' p q ↔ Xor'' p q := by
  unfold Xor''              -- Let's unfold the definition of Xor'' 
  unfold Xor'               -- Let's unfold the definition of Xor'

  constructor               -- To prove iff, we consider the forward case and the converse
  · -- 1. Proving the forward case:
    -- ⊢ p ∧ ¬q ∨ q ∧ ¬p → (p ∨ q) ∧ ¬(p ∧ q)
    intro h                 -- Suppose we know Xor' p q. This implies either: 
                            -- p is true and q is false OR
                            -- q is true and p is false

    -- ⊢ (p ∨ q) ∧ ¬(p ∧ q) -- We show p or q is true but not both.
    constructor
    · -- h : p ∧ ¬q ∨ q ∧ ¬p
      -- 1a. ⊢ p ∨ q        -- Let's prove the left conjunct.
      
      cases h with            -- We will show in either case of our hypothesis h,
                              -- that either p or q is true.

      | inl hl =>             -- Suppose the left disjunct in our hypothesis h is true
      -- hl : p ∧ ¬q
      left                    -- Then we can show p
      -- ⊢ p
      exact hl.left           -- since we know p ∧ ¬q

      | inr hr =>             -- Suppose the right disjunct in our hypothesis h is true
      -- hr : q ∧ ¬p
      right                   -- Then we can show q
      -- ⊢ q
      exact hr.left           -- since we know q ∧ ¬p

    · -- h : p ∧ ¬q ∨ q ∧ ¬p
      -- 1b. ⊢ ¬(p ∧ q)     -- Now let's prove the right conjunct
      
      cases h with          -- We will show in either case of our hypothesis h,
                            -- that neither p and q are true simultaneously.

      | inl hl =>             -- Suppose the left disjunct in our hypothesis h is true
      -- hl : p ∧ ¬q
      -- ⊢ ¬(p ∧ q)
      push_neg                -- This tactic has two modes: in standard mode, 
                              -- it transforms ¬(p ∧ q) into p → ¬q,
                              -- whereas in distrib mode it produces ¬p ∨ ¬q. 
                              -- To use distrib mode, use set_option push_neg.use_distrib true.
                              -- On my system, we use standard mode.
      -- ⊢ p → ¬q
      intro h                 -- Suppose p
      -- h : p
      -- ⊢ ¬q                 -- Show ¬q
      exact hl.right          -- this follows from the left disjunct hl

      | inr hr =>             -- Suppose the right disjunct in our hypothesis h is true 
      -- hr : q ∧ ¬p
      -- ⊢ ¬(p ∧ q)
      rw[not_and_or]          -- We use De Morgan's law
      -- ⊢ ¬p ∨ ¬q            
      left                    -- Then we can show ¬p
      -- ⊢ ¬p
      exact hr.right          -- since we know q ∧ ¬p (hr)
```

It turns out that there is a lemma built into Lean's Mathlib library that can turn the proof above into a single line:
```lean
theorem xor''_equiv (p q : Prop) : Xor' p q ↔ Xor'' p q := by
  exact xor_iff_or_and_not_and p q
```
Searching for an existing proof and re-using it has its merits. It saves time and energy. However, it can abstract away ideas or techniques that may be useful. Always be skeptical of anything handed to you on a "silver platter". Abstract away details of a proof that are not at the focal point of what you're trying to understand. Leave enough detail to emphasize how you understand the proof. 

Here is yet another way of expressing mutual exclusivity:
3. Using if-and-only-if: `p ↔ ¬q`
   - "p and q have different truth values"

Let's define this alternative in Lean:
```lean
def Xor''' (p q : Prop) : Prop := (p ↔ ¬q)
```

If we can show that `Xor'` is equivalent to this new definition `Xor'''`, then as a corollary, we can show `Xor'' ↔  Xor'''`.  Indeed, if we search Mathlib, we can see that we can use `xor_iff_iff_not`:

```lean
theorem xor'''_equiv (p q : Prop) : Xor' p q ↔ Xor''' p q := by
  exact xor_iff_iff_not
```

Now, to prove the corollary, we can simply use our previous two theorems:
```lean
theorem xor_equiv (p q : Prop) : Xor'' p q ↔ Xor''' p q := by
  rw[← xor''_equiv, ← xor'''_equiv]
```

These three definitions are logically equivalent, and each offers a different perspective on what XOR means.

# Symmetry

XOR is symmetric - it doesn't matter which proposition we write first:
```lean
-- symmetry
example (p q : Prop) : Xor' p q = Xor' q p := by
  exact xor_comm p q
```

# Identity
The literals `True` and `False` can also be used in place of Propositions. If we use `False` in XOR, the function simplifies to the identity function:
```lean
example (p : Prop) : Xor' p False ↔ p := by
  unfold Xor'
  -- ⊢ p ∧ ¬False ∨ False ∧ ¬p ↔ p
  rw[not_false_eq_true] 
  -- ⊢ p ∧ True ∨ False ∧ ¬p ↔ p
  rw[and_true]
  --- ⊢ p ∨ False ∧ ¬p ↔ p
  rw[or_and_left]
  -- ⊢ (p ∨ False) ∧ (p ∨ ¬p) ↔ p
  rw[or_false]
  -- ⊢ p ∧ (p ∨ ¬p) ↔ p
  rw[and_or_left]
  -- ⊢ p ∧ p ∨ p ∧ ¬p ↔ p
  rw[and_self]
  -- ⊢ p ∨ p ∧ ¬p ↔ p
  rw[and_not_self_iff]
  -- ⊢ p ∨ False ↔ p
  rw[or_false]
  -- ⊢ p ↔ p (rw closes the goal)
```
Here's another simpler proof and an example of automating proofs. We covered `tauto` in our previous post:
```lean
example (p : Prop) : Xor' p False ↔ p := by
  unfold Xor'
  tauto
  ```

# Associativity
```lean

-- Associativity of XOR: (p XOR q) XOR r ↔ p XOR (q XOR r)
theorem xor_assoc (p q r : Prop) : Xor' (Xor' p q) r ↔ Xor' p (Xor' q r) := by
  simp[Xor']
  tauto

```

# Distributivity

```lean
-- XOR distributes over AND
-- (p XOR q) AND r ↔ (p AND r) XOR (q AND r)
example (p q r : Prop) : Xor' p q ∧ r ↔ Xor' (p ∧ r) (q ∧ r) := by
  constructor
  · -- 1. Forward case
    -- ⊢ Xor' p q ∧ r → Xor' (p ∧ r) (q ∧ r)
    intro h                             -- Suppose h
    -- h : (Xor' p q) ∧ r
    -- ⊢ Xor' (p ∧ r) (q ∧ r)           -- then we show

    cases h.left with                   -- that we can derive the goal
                                        -- in each case of the hypothesis h.left:
                                        -- (p ∧ ¬q) ∨ (q ∧ ¬p).

    | -- h₁ : p ∧ ¬q                      -- Suppose we know p ∧ ¬q.
    inl h₁ =>
      left                                -- We show the left disjunct of Xor'.
      -- ⊢ (p ∧ r) ∧ ¬(q ∧ r)
      constructor
      · -- ⊢ p ∧ r
        constructor                       -- this follows easily from h and h₁
        · exact h₁.left
        · exact h.right
      · -- ⊢ ¬(q ∧ r)
        intro h₂                          -- to show ¬(q ∧ r), assume it by way of contradiction
        -- h₂ : q ∧ r
        -- ⊢ False
        exact h₁.right h₂.left            -- but then we have q ∧ ¬q.

    | -- h₂ : q ∧ ¬p                      -- Now, suppose we know q ∧ ¬p.
    inr h₂ =>
      right                               -- We show the right disjunct of Xor'.
      -- ⊢ (q ∧ r) ∧ ¬(p ∧ r)
      constructor
      · -- ⊢ q ∧ r                        -- this follows easily from h and h₂
        constructor
        · exact h₂.left
        · exact h.right
      · -- ⊢ ¬(p ∧ r)
        intro k                           -- to show ¬(p ∧ r), assume it by way of contradiction
        -- k : p ∧ r
        -- ⊢ False
        exact h₂.right k.left             -- but then we have ¬p ∧ p

  · -- 2. Converse case
    -- ⊢ Xor' (p ∧ r) (q ∧ r) → (Xor' p q) ∧ r
    intro h                             -- Suppose we know h.
    -- h : Xor' (p ∧ r) (q ∧ r)
    -- ⊢ Xor' p q ∧ r                   -- then we show...
    constructor
    · -- ⊢ Xor' p q                     -- Let's prove the left conjunct
      cases h with                      -- Now we show Xor' p q in each case of h,
                                        -- namely, either (p ∧ r) ∧ ¬(q ∧ r) OR
                                        -- (q ∧ r) ∧ ¬(p ∧ r).

      | -- h₁ : (p ∧ r) ∧ ¬(q ∧ r)        -- Suppose the left disjunct of h, h₁
        -- ⊢ Xor' p q                     -- Show this disjunction: (p ∧ ¬q) ∨ (¬p ∧ q).
      inl h₁ =>
        left                              -- We choose to show (p ∧ ¬q).
        -- ⊢ p ∧ ¬q
        constructor
        · -- ⊢ p
          exact h₁.left.left               -- We know p from h₁
        · -- ⊢ ¬q
          intro hq                         -- to show ¬q, assume q by way of contradiction
          -- hq : q
          -- ⊢ False
          exact h₁.right ⟨hq, h₁.left.right⟩-- then ¬(q ∧ r) and (q ∧ r)
                                           -- using implication,
                                           -- (q ∧ r) → False
                                           -- and we know (q ∧ r)

      | -- h₁ : (q ∧ r) ∧ ¬(p ∧ r)         -- Now, suppose the right disjunct of h, h₁
        -- ⊢ Xor' p q                      -- Show this disjunction: (p ∧ ¬q) ∨ (¬p ∧ q).
      inr h₁ =>
        right                              -- We choose to show (¬p ∧ q)
        -- ⊢ q ∧ ¬p                        -- or equivalently, q ∧ ¬p (conjunction commutes)
        constructor
        · -- ⊢ q
          exact h₁.left.left                -- We know q from h₁
        · -- ⊢ ¬p
          intro hp                          -- to show ¬p, assume p by way of contradiction
          -- hp : p
          -- ⊢ False
          exact h₁.right ⟨hp, h₁.left.right⟩ -- then ¬(p ∧ r) and (p ∧ r)

    · -- h : Xor' (p ∧ r) (q ∧ r)         -- Let's prove the right conjunct.
      -- ⊢ r                              -- Now we show that in each case of h,
      cases h with                        -- we can derive r.
      | -- h₁ : (p ∧ r) ∧ ¬(q ∧ r)
      inl h₁ =>
        exact h₁.left.right               -- r follows easily from h₁
      | -- h₁ : (q ∧ r) ∧ ¬(p ∧ r)
      inr h₂ =>
        exact h₂.left.right               -- ... and from h₂
```

**Practice Problems:**
Try exploring these questions:

```lean
-- What if we use True instead of False?
example (p : Prop) : Xor' p True ↔ ¬p := by
  sorry

-- What can we conclude with different versions of Xor?
example (p q : Prop) : Xor' p q → ¬(p ∧ q) := by
  sorry

-- What if we use the same proposition in Xor?
example (p : Prop) : Xor' p p → False := by
  sorry

-- Given p XOR q and q XOR r, what can you say about p XOR r?
example (p q r : Prop) : Xor' p q ∧ Xor' q r → (Xor' (¬p) r) := by
  sorry
```

