---
title: 'Propositions: Part 4'
date: 2025-10-06
permalink: /posts/2025/10/blog-post-6/
tags:
  - lean
  - logic
  - propositions
  - exclusive or
---

In our previous discussions of disjunction, we introduced two interpretations: inclusive "or" (where both statements can be true) and exclusive "or" (where exactly one statement must be true). Today, we'll dive deep into exclusive or (XOR) and how it relates to mutual exclusivity in mathematics. The mutual exclusion operator is sometimes denoted with `p ^ q` or `p xor q`. As we will see in Lean, we use pre-order notation.

# Understanding Mutual Exclusivity

In mathematics, we often encounter properties that occur individually but cannot occur simultaneously. For example:
- A number cannot be both even and odd
- A real number being either rational or irrational
- An element cannot be both in a set and not in a set

This concept of mutual exclusivity is fundamental to mathematical reasoning. When two properties are mutually exclusive, they cannot be true at the same time - the truth of one implies the falsity of the other.

# Expressing XOR in Lean

Lean provides multiple ways to work with "exclusive or". Let's explore them:

## 1. Boolean XOR

The simplest form is the boolean `xor` function:
```lean 
#check xor -- Bool -> Bool -> Bool
The type of this function takes two Bool arguments and returns a Bool. In Lean, `True` and `False` are boolean literals.
-- Truth table:
#eval xor True True   -- false (can't both be true)
#eval xor False False -- false (can't both be false)
#eval xor True False  -- true  (exactly one is true)
#eval xor False True  -- true  (exactly one is true)
```
xor evaluates to `True` when the booleans have different values and `False` otherwise. 

## 2. Proposition-Level XOR

For logical proofs, we need to work with Propositions. In Lean, `Xor'` is defined as follows
```lean
Xor' (a b : Prop) : Prop
```
This is exactly what we'll need to prove statements about mutual exclusivity of propositions. Let's see how this function is expressed using compound propositions we have encountered previously.

```lean
import Mathlib.Tactic

example (p q : Prop) : Xor' p q ↔ (p ∧ ¬q) ∨ (q ∧ ¬ p) := by
  rw[Xor']
```

This definition directly captures the meaning of XOR: either `p` is true and `q` is false, OR `q` is true and `p` is false. You can compute the truth table for `(p ∧ ¬q) ∨ (q ∧ ¬p)` to convince yourself of this equivalence.

# Three Equivalent Definitions

There are multiple ways to define mutual exclusivity:

1. Direct Definition: `(p ∧ ¬q) ∨ (q ∧ ¬p)`
   - "Either p is true and q is false, or q is true and p is false"

2. Using OR and NOT-AND: `(p ∨ q) ∧ ¬(p ∧ q)`
   - "At least one is true, but not both"

We can encode this definition in Lean using the `def` keyword to define a function. Its signature is similar to `Xor'`. It takes two propositions `p` and `q` of type `Prop` and returns a `Prop`: 
```lean
def Xor'' (p q : Prop) : Prop := (p ∨ q) ∧ ¬(p ∧ q)
```

Now that we have two definitions, let's try proving their equivalence. 

```lean
example (p q : Prop) : Xor' p q ↔ Xor'' p q := by
  unfold Xor''              -- Let's unfold the definition of Xor'' 
  unfold Xor'               -- Let's unfold the definition of Xor'

  constructor               -- To prove iff, we consider the forward case and the converse
  · -- 1. Proving the forward case:
    -- ⊢ p ∧ ¬q ∨ q ∧ ¬p → (p ∨ q) ∧ ¬(p ∧ q)
    intro h                 -- Suppose we know Xor' p q. This implies either: 
                            -- p is true and q is false OR
                            -- q is true and p is false

    -- ⊢ (p ∨ q) ∧ ¬(p ∧ q) -- We show p or q is true but not both.
    constructor
    · -- h : p ∧ ¬q ∨ q ∧ ¬p
      -- 1a. ⊢ p ∨ q        -- Let's prove the left conjunct.
      
      cases h with            -- We will show in either case of our hypothesis h,
                              -- that either p or q is true.

      | inl hl =>             -- Suppose the left disjunct in our hypothesis h is true
      -- hl : p ∧ ¬q
      left                    -- Then we can show p
      -- ⊢ p
      exact hl.left           -- since we know p ∧ ¬q

      | inr hr =>             -- Suppose the right disjunct in our hypothesis h is true
      -- hr : q ∧ ¬p
      right                   -- Then we can show q
      -- ⊢ q
      exact hr.left           -- since we know q ∧ ¬p

    · -- h : p ∧ ¬q ∨ q ∧ ¬p
      -- 1b. ⊢ ¬(p ∧ q)     -- Now let's prove the right conjunct
      
      cases h with          -- We will show in either case of our hypothesis h,
                            -- that neither p and q are true simultaneously.

      | inl hl =>             -- Suppose the left disjunct in our hypothesis h is true
      -- hl : p ∧ ¬q
      -- ⊢ ¬(p ∧ q)
      push_neg                -- This tactic has two modes: in standard mode, 
                              -- it transforms ¬(p ∧ q) into p → ¬q,
                              -- whereas in distrib mode it produces ¬p ∨ ¬q. 
                              -- To use distrib mode, use set_option push_neg.use_distrib true.
                              -- On my system, we use standard mode.
      -- ⊢ p → ¬q
      intro h                 -- Suppose p
      -- h : p
      -- ⊢ ¬q                 -- Show ¬q
      exact hl.right          -- this follows from the left disjunct hl

      | inr hr =>             -- Suppose the right disjunct in our hypothesis h is true 
      -- hr : q ∧ ¬p
      -- ⊢ ¬(p ∧ q)
      rw[not_and_or]          -- We use De Morgan's law
      -- ⊢ ¬p ∨ ¬q            
      left                    -- Then we can show ¬p
      -- ⊢ ¬p
      exact hr.right          -- since we know q ∧ ¬p (hr)
```

It turns out that there is a lemma built into Lean's Mathlib library that can turn the proof above into a single line:
```lean
theorem equiv (p q : Prop) : Xor' p q ↔ Xor'' p q := by
  exact xor_iff_or_and_not_and p q
```
Searching for an existing proof and re-using it has its merits. It saves time and energy. However, it can abstract away ideas or techniques that may be useful. Always be skeptical of anything handed to you on a "silver platter". Abstract away details of a proof that are not at the focal point of what you're trying to understand. Leave enough detail to emphasize how you understand the proof. 

Here is yet another way of expressing mutual exclusivity:
3. Using if-and-only-if: `p ↔ ¬q`
   - "p and q have different truth values"

Let's define this alternative in Lean:
```lean
def Xor''' (p q : Prop) : Prop := (p ↔ ¬q)
```

```lean
theorem xor_equiv (p q : Prop) : Xor' p q ↔ Xor''' p q := by
  exact xor_iff_iff_not
```

These three definitions are logically equivalent, and each offers a different perspective on what XOR means.

# Key Properties of XOR

## 1. Symmetry

XOR is symmetric - it doesn't matter which proposition we write first:
```lean
-- symmetry
example (p q : Prop) : Xor' p q = Xor' q p := by
  exact xor_comm p q
```

# Practical Examples

Let's look at some mathematical examples where XOR naturally appears:

1. Even vs Odd:
```lean
def Even (n : ℕ) : Prop := ∃ k, n = 2 * k
def Odd (n : ℕ) : Prop := ∃ k, n = 2 * k + 1

-- Every natural number is either even XOR odd
theorem even_xor_odd (n : ℕ) : Xor' (Even n) (Odd n)
```

2. Set Membership:
```lean
-- For any element x and set A:
-- x is either in A XOR not in A
theorem in_xor_not_in {α : Type} (x : α) (A : Set α) :
  Xor' (x ∈ A) (x ∉ A)
```

# Why XOR Matters

XOR is crucial in mathematics because it helps us:
1. Express mutually exclusive alternatives clearly
2. Prove properties about classifications (like even/odd)
3. Establish fundamental logical relationships
4. Formalize the concept of "exactly one of these is true"

In our next post, we'll explore more complex proofs involving XOR and see how it interacts with other logical operators.

## Exercises

1. Prove that if p XOR q is true, then p and q cannot both be true.
2. Show that XOR is symmetric (p XOR q ↔ q XOR p).
3. Prove that for any proposition p, p XOR p is false.
4. Given p XOR q and q XOR r, what can you say about p XOR r?