---
title: 'Quantifiers: Part 2'
date: 2025-10-20
permalink: /posts/2025/10/blog-post-8/
tags:
  - lean
  - logic
  - quantifiers
  - exists
---

In the last post we introduced the notion of a universal quantifier. We now take a look at the existential quantifier.

`use` tactic    
- Split an existential goal into providing a witness
- Leave you with proving the property for that witness

```lean
-- next, let's look at the existential quantifier
example : ∃ n : ℕ, n + 1 = 5 := by
  use 4 -- provide a concrete term to satisfy conclusion

-- providing a witness to solve ∃ goals
-- you need to derive a given that has Q a for some instance a
example (h : P 3 → Q 3) (p3 : P 3) : ∃x, Q x := by
  have q3 := h p3
  -- q3 : Q 3
  -- ⊢ ∃ x, Q x
  use 3

-- also by reasoning backwards
example (h : P 3 → Q 3) (p3 : P 3) : ∃x, Q x := by
  use 3
  -- ⊢ Q 3
  apply h
  -- ⊢ P 3
  exact p3

-- if the existential is a hypothesis, you can provide a value
-- using the cases tactic. The value can be named by
example : (∃ x : ℕ, x > 0) → True := by
  intro h      -- Suppose ∃x, x > 0, show True
  -- h : ∃ x, x > 0
  -- ⊢ True
  cases h with -- let x : ℕ  s.t. x > 0
  | intro x hx =>
  -- x : ℕ
  -- hx : x > 0
  trivial
```

```lean
-- Instantiating with ∃ using cases
-- Use the cases tactic with ∃ to instantiate
-- exists tactic closes this type of goal
example (h : ∃ x, P x) : ∃ y, P y := by
  cases h with     -- let a s.t. P a
  | intro a ha =>
  -- a : ℕ 
  -- ha : P a
  use a         -- then we have just constructed a s.t. P a

-- Instantiating with ∃ using obtain
-- Use the obtain deconstructor on ∃ to instantiate
example (h : ∃ x, P x) : ∃ y, P y := by
  obtain ⟨ a, ha ⟩ := h
  -- a : ℕ
  -- ha : P a
  exists a         -- then we have just constructed a s.t. P a
  ```

  ```lean
  
-- commutativity of ∃ over ∧
example (h : ∃ x, P x ∧ Q x) : (∃ x, P x) ∧ (∃ x, Q x) := by
  obtain ⟨ a, ha ⟩ := h -- let a s.t. P a ∧ Q a
  -- a  : ℕ
  -- ha : P a ∧ Q a
  constructor          -- show (case 1) ∃ Px and  (case 2) ∃ Qx
  · -- ⊢ ∃ x, P x
    use a           -- case 1: consider a, show P a
    -- ⊢ P a
    exact ha.left      -- this follows from hypothesis (left)
  · -- ⊢ ∃ x, Q x
    exists a           -- case 2: consider a, show Q a
    -- ⊢ Q a
    exact ha.right     -- this follows from hypothesis (right)


-- ∃ distributes over ∨
-- You can nest cases inside other cases based on hypotheses available
example (h : ∃ x, P x ∨ Q x) : (∃ x, P x) ∨ ( ∃ x, Q x) := by
  obtain ⟨ a, qa ⟩ := h -- Suppose a ∈ ℕ s.t. P a ∨ Q a
  -- a : ℕ
  -- qa : P a ∨ Q a
  cases qa with
  | -- j : P a
    inl j =>           -- Suppose P a is true
    left               -- then we show ∃x P x
    -- ⊢ ∃ x, P x
    use a           -- use a s.t. P a

  | -- k : Q a
    inr k =>           -- Suppose Q a is true
    right              -- then we show ∃x Q x
    -- ⊢ ∃ x, Q x
    use a           -- use a s.t. Q a

```