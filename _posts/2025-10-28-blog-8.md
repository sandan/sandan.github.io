---
title: 'Quantifiers: Part 2'
date: 2025-10-20
permalink: /posts/2025/10/blog-post-8/
tags:
  - lean
  - logic
  - quantifiers
  - exists
---

In the last post we introduced the notion of a universal quantifier. This allowed us to state propositions that hold for all members of a set (the set of natural numbers in our case). We now take a look at the existential quantifier. The existential quantifier is denoted symboliccaly as "∃". Just like the universal quantifier, it binds a single variable.

Many interesting propositions are about the *existence* of something that satisfies a certain property. The existential quantifier is used to prove propositions that talk about "at least one" or "some" element `x` that satisifies a statement `P(x)`. Some examples are:

- Is there a number whose square is -1?
- Is there an efficient algorithm that can decompose a natural number to its primes?
- Is there a coloring of a planar map with only four colors?

## Existential introduction
When we have an existentially quanitfied proposition in the goal, we have to construct a value (sometimes called a witness) and provide it to the goal. The `use` tactic does this. Here's our first example:

```lean
example : ∃ n : ℕ, n + 1 = 5 := by
  -- ⊢ ∃ n, n + 1 = 5
  use 4 -- provide a concrete term to satisfy conclusion
```
The goal in the previous example say that there is a natural number `n` that satisfies this equation `n + 1 = 5`. The literal value 4 satisfies the equation.

The values the `use` tactic can also handle are: 
- arithmetical expressions
```lean
example : ∃ n : ℕ, n + 1 = 5 := by
  -- ⊢ ∃ n, n + 1 = 5
  use (2 * 2) 
  -- Let n = 2 * 2
```
- multiple variables
```lean
/-- Multiple exists with use tactic -/
example : ∃ (x y : ℕ), x + y = 5 := by
  use 2, 3     
  -- Let x = 2 and y = 3
```
- The `use` tactic can also work on pairs. The syntax `.1` retrieves the first component of the pair and `.2` retrieves the second component of the pair.
```lean
example : ∃ (x : ℕ × ℕ), x.1 + x.2 = 5 := by
  use (2, 3)     
  -- Let x be the pair of natural numbers (2, 3)
  -- ⊢ (2, 3).1 + (2, 3).2 = 5
  rfl
```
- inequalities
```lean
example (n : ℕ) : ∃ (m : ℕ), m > n := by
  use n + 1 
  -- ⊢ n + 1 > n
  apply Nat.lt_succ_self 
```

We have not worked with natural numbers in detail. We will in future posts where we use built-in lemmas in Lean's Mathlib, such as `lt_succ_self` used in the previous example, to prove propositions about natural numbers:

```lean
#check Nat.lt_succ_self
-- Nat.lt_succ_self (n : ℕ) : n < n.succ
```

When we check the type of the lemma, it takes a natural number `n` and returns a proof that `n` is strictly less than its successor (`n + 1`). This proof is exactly what is needed to close the goal in the previous example.


Let's look at another example using propositions P and Q. Recall that P and Q have the type: `ℕ → Prop`. These are propositions that depend on a natural number. For example, `P` could be "x > 0". So `P 3` is the proposition "3 > 0".

```lean
example (h : P 3 → Q 3) (p3 : P 3) : ∃x, Q x := by
  have q3 := h p3
  -- q3 : Q 3
  -- ⊢ ∃ x, Q x
  use 3
```
The `use` tactic provides the value to the existential quantifier, removing it. It instantiates the proposition with a concrete value, leaving you with proving the property for that value.

We could have also provided the value first:
```lean
example (h : P 3 → Q 3) (p3 : P 3) : ∃x, Q x := by
  use 3             -- Let x = 3.
  -- ⊢ Q 3          -- Then we show Q 3
  exact h p3        -- by modus ponens.
```

Can you finish this proof by reasoning backwards from `Q 3`?
```lean
example (h : P 3 → Q 3) (p3 : P 3) : ∃x, Q x := by
  use 3
  -- ⊢ Q 3
  sorry
```

The `use` tactic is similar to `apply` in that it works backwards. The rule of Existential Introduction says that if you have a concrete witness or value `c` that satisfies proposition `Q`, then you can conclude `∃x, Q x`. The `use` tactic reduces the existentially quantified goal (`∃x, Q x`) to the goal with the provided witness (`Q c`). If the new goal can be proven, we can conclude the more general proposition`∃x, Q x` (introduce ∃). That is why Existential Introduction is also called Existential Generalization.

## Existential elimination
Suppose you have an existential statement that you want to use. Perhaps it is a hypothesis. You can instantiate a witness from the existential statement using the `cases` tactic or the `obtain` tactic. Both of these tactics introduce new hypotheses that you can use throughout the proof. Let's look at an example with `cases`:

```lean
example : (∃ x : ℕ, x > 0) → True := by
  intro h            -- Suppose ∃x, x > 0
  -- h : ∃ x, x > 0
  -- ⊢ True
  cases h with      -- let x : ℕ  s.t. x > 0
  | intro x hx =>
  -- x : ℕ
  -- hx : x > 0
  trivial
```
Notice there is only one arm in the `cases` tactic that uses `intro` to instantiate a witness. This introduces a natural number `x` and a hypothesis `hx`. The proof is trivial since natural numbers are positive by definition.

Let's look at a similar tactic `obtain`:
```lean
example : (h : ∃ x, P x) → True := by
  intro H
  -- ∃ x, P x
  obtain ⟨ a, ha ⟩ := H
  -- a : ℕ
  -- ha : P a
  trivial
```
We provide a hypothesis that is an existentially quantified statement to the `obtain` tactic. We get back a natural number `a` and a hypothesis `ha` containing proposition `P a`. The tactic takes an existential statement and deconstructs it -- instantiating a witness and a proposition about it. The Existential Elimination rule is also called the Existential Instantiation rule for that reason.

Can you see where the rule of existential introduction and instantitation are used in the following example?

```lean
example (h : ∃ x, P x) : ∃ y, P y := by
  obtain ⟨ a, ha ⟩ := h  -- Let a be a natural number satisfying P
  -- a : ℕ
  -- ha : P a
  use a                 -- then there is a natural number satisfying P.
```

## Existential Conjunction
Let's look at an example where existential quanitfiers are used with conjunctions. In our first example, we show that the existential quantifier can be "distributed" over the conjunction:
```lean
example (h : ∃ x, P x ∧ Q x) : (∃ x, P x) ∧ (∃ x, Q x) := by
  obtain ⟨ a, ha ⟩ := h -- let a s.t. P a ∧ Q a
  -- a  : ℕ
  -- ha : P a ∧ Q a
  constructor          -- show (case 1) ∃ Px and (case 2) ∃ Qx
  · -- ⊢ ∃ x, P x
    use a              -- case 1: consider a, show P a
    -- ⊢ P a
    exact ha.left      -- this follows from hypothesis (left)
  · -- ⊢ ∃ x, Q x
    exists a           -- case 2: consider a, show Q a
    -- ⊢ Q a
    exact ha.right     -- this follows from hypothesis (right)
```
The hypothesis is strong. It says that there is an element `x` such that `P x` and `Q x` is true. The same instance `x` can be used to satisfy both `P` and `Q`. The converse uses a weaker pre-supposition:

```lean
example (h : (∃ x, P x) ∧ (∃ x, Q x) ): ∃ x, P x ∧ Q x := by
    sorry
```
If we tried proving this, we'd see that just because each existentially quantified conjunct has its own `x` that satisfies `P` and `Q`, it may not be the case that that the same instance `x` satisfies `P` and `Q` simultaneously. Another way of expressing an equivalent hypothesis to the one in the previous example is `(∃ x, P x) ∧ (∃ y, Q y)`. Unless `x` and `y` are equal, we can't necessarily conclude `∃ x, P x ∧ Q x`.

Let's provide a counter-example to see this intuitively. For example, suppose `P` is the proposition that `x` is odd and `Q` is the proposition that `y` is greater than 10. Then one counter-example would be to show an odd number less than or equal to 10. Namely, 7.

## Existential Disjunction
In the next example, we show that the existential quantifier can "distribute" over the disjunction:
```lean
-- ∃ distributes over ∨
-- You can nest cases inside other cases based on hypotheses available
example (h : ∃ x, P x ∨ Q x) : (∃ x, P x) ∨ ( ∃ x, Q x) := by
  obtain ⟨ a, qa ⟩ := h -- Suppose a ∈ ℕ s.t. P a ∨ Q a
  -- a : ℕ
  -- qa : P a ∨ Q a
  cases qa with
  | -- j : P a
    inl j =>           -- Suppose P a is true
    left               -- then we show ∃x P x
    -- ⊢ ∃ x, P x
    use a              -- use a s.t. P a

  | -- k : Q a
    inr k =>           -- Suppose Q a is true
    right              -- then we show ∃x Q x
    -- ⊢ ∃ x, Q x
    use a              -- use a s.t. Q a

```


```lean
-- Instantiating with ∃ using cases
-- Use the cases tactic with ∃ to instantiate
-- exists tactic closes this type of goal
example (h : ∃ x, P x) : ∃ y, P y := by
  cases h with     -- let a s.t. P a
  | intro a ha =>
  -- a : ℕ 
  -- ha : P a
  use a         -- then we have just constructed a s.t. P a
```
