---
title: 'Quantifiers: Part 2'
date: 2025-10-20
permalink: /posts/2025/10/blog-post-8/
tags:
  - lean
  - logic
  - quantifiers
  - exists
---

In the last post we introduced the notion of a universal quantifier. This allowed us to state propositions that hold for all members of a set (the set of natural numbers in our case). We now take a look at the existential quantifier. Many interesting propositions are about the existence of something that satisfies a certain property. The existential quantifier is used to prove propositions that talk about "at least one" or "some" element `x` that satisifies a statement `P(x)`. Once we establish whether something does indeed exist, we wonder whether it is unique.

- Is there a number whose square is -1?
- Is there an efficient algorithm that can decompose a natural number to its primes?
- Is there a

When we have an existentially quanitfied proposition in the goal, we have to construct a value (sometimes called a witness) and provide it to the goal. The `use` tactic does this.

```lean
example : ∃ n : ℕ, n + 1 = 5 := by
  -- ⊢ ∃ n, n + 1 = 5
  use 4 -- provide a concrete term to satisfy conclusion
```
The goal in the previous example say that there is a natural number `n` that satisfies this equation `n + 1 = 5`. The literal value 4 satisfies the equation. The tactic can also handle expressions:
```lean
example : ∃ n : ℕ, n + 1 = 5 := by
  -- ⊢ ∃ n, n + 1 = 5
  use (2 * 2) -- provide an expression
```

Let's look at another example using propositions P and Q. Recall that P and Q have the type: `ℕ → Prop`. These are propositions that depend on a natural number. For example, `P` could be "x > 0". So `P 3` is the proposition "3 > 0", which can readily be seen to be true.

```lean
-- providing a witness to solve ∃ goals
-- you need to derive a given that has Q a for some instance a
example (h : P 3 → Q 3) (p3 : P 3) : ∃x, Q x := by
  have q3 := h p3
  -- q3 : Q 3
  -- ⊢ ∃ x, Q x
  use 3
```
The `use` tactic provides the value to the existential quantifier, removing it. It instantiates the proposition with a concrete value, leaving you with proving the property for that value.

We could have also provided the value first:
```lean
example (h : P 3 → Q 3) (p3 : P 3) : ∃x, Q x := by
  -- ⊢ ∃ x, Q x
  use 3             -- Let x = 3.
  -- ⊢ Q 3          -- Then we show Q 3
  exact h p3        -- by modus ponens.
```

Can you finish this proof by reasoning backwards from `Q 3`?
```lean
example (h : P 3 → Q 3) (p3 : P 3) : ∃x, Q x := by
  use 3
  -- ⊢ Q 3
```

Now -- if the existential is a hypothesis, you can provide a value
-- using the cases tactic. 
```lean
example : (∃ x : ℕ, x > 0) → True := by
  intro h      -- Suppose ∃x, x > 0, show True
  -- h : ∃ x, x > 0
  -- ⊢ True
  cases h with -- let x : ℕ  s.t. x > 0
  | intro x hx =>
  -- x : ℕ
  -- hx : x > 0
  trivial
```

```lean
-- Instantiating with ∃ using cases
-- Use the cases tactic with ∃ to instantiate
-- exists tactic closes this type of goal
example (h : ∃ x, P x) : ∃ y, P y := by
  cases h with     -- let a s.t. P a
  | intro a ha =>
  -- a : ℕ 
  -- ha : P a
  use a         -- then we have just constructed a s.t. P a

-- Instantiating with ∃ using obtain
-- Use the obtain deconstructor on ∃ to instantiate
example (h : ∃ x, P x) : ∃ y, P y := by
  obtain ⟨ a, ha ⟩ := h
  -- a : ℕ
  -- ha : P a
  exists a         -- then we have just constructed a s.t. P a
  ```

  ```lean
  
-- commutativity of ∃ over ∧
example (h : ∃ x, P x ∧ Q x) : (∃ x, P x) ∧ (∃ x, Q x) := by
  obtain ⟨ a, ha ⟩ := h -- let a s.t. P a ∧ Q a
  -- a  : ℕ
  -- ha : P a ∧ Q a
  constructor          -- show (case 1) ∃ Px and  (case 2) ∃ Qx
  · -- ⊢ ∃ x, P x
    use a           -- case 1: consider a, show P a
    -- ⊢ P a
    exact ha.left      -- this follows from hypothesis (left)
  · -- ⊢ ∃ x, Q x
    exists a           -- case 2: consider a, show Q a
    -- ⊢ Q a
    exact ha.right     -- this follows from hypothesis (right)


-- ∃ distributes over ∨
-- You can nest cases inside other cases based on hypotheses available
example (h : ∃ x, P x ∨ Q x) : (∃ x, P x) ∨ ( ∃ x, Q x) := by
  obtain ⟨ a, qa ⟩ := h -- Suppose a ∈ ℕ s.t. P a ∨ Q a
  -- a : ℕ
  -- qa : P a ∨ Q a
  cases qa with
  | -- j : P a
    inl j =>           -- Suppose P a is true
    left               -- then we show ∃x P x
    -- ⊢ ∃ x, P x
    use a           -- use a s.t. P a

  | -- k : Q a
    inr k =>           -- Suppose Q a is true
    right              -- then we show ∃x Q x
    -- ⊢ ∃ x, Q x
    use a           -- use a s.t. Q a

```