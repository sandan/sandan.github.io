---
title: 'Propositions: Part 1'
date: 2014-08-08
permalink: /posts/2025/08/blog-post-3/
tags:
  - lean
  - logic
  - propositions
---

In this post, we will start with propositions to introduce proofs in Lean step by step.

Propositions are sentences in a natural language that are either True or False. Some examples of interesting Propositions are:
- "Pyramids in Egypt are at least 4000 years old."
- "Factoring any natural number can be done in polynomial time."
- "Even in a perfect logical system about natural numbers, there will be true propositions that cannot be proven within that system."
- "Natural numbers exist independently of humans."

A proposition is still True or False even if we don't know if it is True or False. For our purposes, we will focus on symbolic logic and use letters `P` or `Q` to stand in for your favorite proposition(s).

 In Lean, there is a built-in type called `Prop`. Lean knows that elements of type `Prop` have operations that can be used on them: ∧, ∨, ¬, →, ↔.

The VS code editor allows typing these symbols by typing `\` then :
```lean
-- iff for ↔
-- to for →
-- and for ∧
-- or for ∨
-- not (negation) for ¬ 
-- exists for ∃
-- forall for ∀
```

A first look at Lean
========
```lean
-- import statements
import Mathlib.Tactic  -- Imports most common tactics
import Mathlib.Data.Nat.Basic  -- Basic natural number properties
```
Import statements are used in Lean to provide built-in types that we can use. [Mathlib is the standard library for mathematical reasoning](https://github.com/leanprover-community/mathlib4/tree/master/Mathlib) in Lean4. Whenever we use a new library in the blog, we'll mention importing it.

Let's look at proving something easy.
```lean
-- Here is a simple example.
-- The goal is to show True.
example : True := by
  -- ⊢ True
  trivial
  -- ✅ Goal solved!

```
The `example` keyword can be used to introduce expressions that can be proven in tactic mode. The lean tactic mode is started by the `by` symbol. In tactic mode, a goal is the expression shown using the turnstile symbol ⊢. The expression in the goal is proven or solved by taking what you are given (hypotheses or lemmas) and using tactics to derive the goal. Tactics are built-in rules (keywords) in Lean that alter the Tactic State. The Tactic State shows what is known and the goal. The Tactic State is shown in the VS Code editor InfoView. I'll typically show the interesting parts of the Tactic State in the comments of the lean code snippets.

In this case, we have just proven a goal whose expression is `True`. We used a tactic called `trivial` to close the goal (prove it). It can be used whenever the goal is `True`. If the goal is `False`, then lean will not have any tactics that you can use to close the goal (prove it). If you manage to prove something False, it could be a bug in lean. More likely, if you are in this case, it is typically a faulty definition, theorem, lemma, or something that relies on a tactic called `sorry`. The `sorry` tactic is used to close any goal - it tells the lean interpreter to suspend disbelief. The ultimate hand-waving.

Here are more examples:

```lean
-- This example claims that P (the conclusion) is true.
-- The hypothesis states that P is true
example (p : Prop) (h : p) : p := by
  exact h
-- this is the probably the easiest thing to prove
-- the conclusion is given to you in the hypothesis gives the conclusion

-- lean has a shorthand tactic to use when a hypothesis
-- gives the current goal
example (p : Prop) (h : p) : p := by
  assumption

-- When you combine two propositions P, Q to create another 
-- proposition P ∧ Q, we call this new proposition the conjunction of P and Q.
--
-- P ∧ Q evaluates to true if both P and Q are true statements.
--
-- In Lean, we use the constructor tactic to take the goal
-- and break the conjunction into subgoals. Each subgoal requires a proof.
-- A dot (· (`\.`)) is used to specify the proof for that subgoal.
-- There are two cases since the conjunction has two propositions.
example (p q : Prop) (h1 : p) (h2 : q) : p ∧ q := by
  -- p q : Prop
  -- h1 : p
  -- h2 : q
  -- ⊢ p ∧ q
  constructor
  · -- ⊢ p
    exact h1
  · -- ⊢ q
    exact h2

-- Given a conjunction (h : p ∧ q), conclude p 

-- One way to approach this is to introduce a new intermediate hypothesis.
-- The `have` tactic is used to create a new hypothesis labeled by hp.

-- hp is defined (:=) by the expression h.1. This dot notation is used to select
-- p from the conjunction h. Similarly h.2 can be used to select q from the conjunction.
example (p q : Prop) (h : p ∧ q) : p := by
  -- h : p ∧ q
  -- ⊢ p
  have hp := h.1
  -- h : p ∧ q
  -- hp : p
  -- ⊢ p
  exact hp

-- the propositions in the hypothesis h can also be referenced by left/right.
example (p q : Prop) (h : p ∧ q) : q := by
  -- p q : Prop
  -- h : p ∧ q
  -- ⊢ q
  have hq := h.right
  -- h : p ∧ q
  -- hq : q
  -- ⊢ q
  exact hq

-- the goal can be closed more directly using the `exact` tactic.
example (p q : Prop) (h : p ∧ q) : q := by
  -- p q : Prop
  -- h : p ∧ q
  -- ⊢ q
  exact h.right
  
-- Next we show that conjunction is commutative
example (p q : Prop) (h : p ∧ q) : q ∧ p := by
  -- p q : Prop
  -- h : p ∧ q
  -- ⊢ q ∧ p
  cases h with
  | intro hp hq => -- introduce the propositions as hp and hq resp.
    -- hp : p
    -- hq : q
    -- ⊢ q ∧ p
    constructor
    · -- ⊢ q
      exact hq
    · -- ⊢ p
      exact hp
 
-- When there are more than two propositions joined in a conjunction,
-- the constructor tactic can be used twice. The sub-goals depend on 
-- how the terms are associated. With no explicit parentheses,
-- the parentheses group the right-most: p ∧ q ∧ r = p ∧ (q ∧ r).

-- Note that the dots are still needed to focus which tactic solves which subgoal
-- Also note that all the proofs of the subgoals needed a ⬝ except the constructor tactic
theorem p4 (p q r : Prop) (h1 : p) (h2 : q) (h3 : r) : p ∧ q ∧ r := by
  -- h1 : p
  -- h2 : q
  -- h3 : r
  -- ⊢ p ∧ q ∧ r
  constructor --break the goal into two subgoals
  · -- ⊢ p
    exact h1 -- prove the first case (the one above)
  · -- ⊢ q ∧ r
    constructor -- break the second goal further into subgoals ( the one below)
    · -- ⊢ q
      exact h2
    · -- ⊢ r
      exact h3

```

One way to think about this game of proving things is like a map. You are trying to get to the destination from where you are at. The destination is the expression in the goal (⊢). The tactics are the cars that get us from one point on the map to another. The hypotheses and lemmas are like the roads on the map. The car can only get from point A to point B on the map if there are hypotheses or lemmas that allow it to do so. A proof in this analogy is a valid route (you aren't going off-road!) from your current location to the destination.

Just like in real life, there may be many roads to the destination. Also like in real-life, some destinations are harder to get to than others. Some destinations are currently unreachable - buried under ancient icebergs, dense rainforest, ancient desert, soaring mountaintops - you get the idea. The harder the destination to get to, the harder it is to find roads. The role of research in mathematics is to build these roads to allow us to make these hard and far-away destinations more accessible.

Try providing a proof for these examples:
```lean
example (p q : Prop) (h : q) : (q ∧ q) := by 
  sorry

example (p q : Prop) (h : p ∧ q) : (p ∧ q) ∧ q := by 
  sorry

example (p q : Prop) (h1 : p) (h2 : q) : (p ∧ q) ∧ p := by 
  sorry

example (p q : Prop) (h1 : p ∧ p) (h2 : q) : (p ∧ q) ∧ p := by 
  sorry

example (p q r : Prop) (h : p ∧ q ∧ r) : p ∧ r := by
  sorry
```