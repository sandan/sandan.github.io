---
title: 'Propositions: Part 1'
date: 2025-08-08
permalink: /posts/2025/08/blog-post-3/
tags:
  - lean
  - logic
  - propositions
  - conjunction
---

In this post, we'll introduce propositions and begin exploring proofs in Lean step by step.

## What Are Propositions?

Propositions are statements that are either true or false. Here are some interesting examples:
- "The pyramids in Egypt are at least 4000 years old."
- "Factoring any natural number can be done in polynomial time."
- "Even in a perfect logical system about natural numbers, there will be true propositions that cannot be proven within that system."
- "Natural numbers exist independently of humans."

A key insight: a proposition has a definite truth value even when we don't know whether it's true or false. For our purposes, we'll focus on symbolic logic, using letters like `P` and `Q` to represent arbitrary propositions.

In Lean, there's a built-in type called `Prop`. Elements of this type support logical operations: ∧ (and), ∨ (or), ¬ (not), → (implies), and ↔ (if and only if).

### Typing Logical Symbols in VS Code

The VS Code editor lets you type these symbols using backslash shortcuts:
```lean
-- iff for ↔
-- to for →
-- and for ∧
-- or for ∨
-- not for ¬ 
-- exists for ∃
-- forall for ∀
```

## Getting Started with Lean

First, we need to import the necessary libraries:

```lean
-- import statements
import Mathlib.Tactic  -- Imports most common tactics
import Mathlib.Data.Nat.Basic  -- Basic natural number properties
```

Import statements provide built-in types and functions. [Mathlib is the standard library for mathematical reasoning](https://github.com/leanprover-community/mathlib4/tree/master/Mathlib) in Lean 4. We'll mention any new imports as we introduce them.

### Your First Proof

Let's start with something simple:

```lean
-- Here is a simple example.
-- The goal is to show True.
example : True := by
  -- ⊢ True
  trivial
  -- ✅ Goal solved!

```

This introduces several key concepts:
- **`example`**: Used to state and prove expressions in tactic mode
- **`by`**: Starts tactic mode for interactive proving
- **`⊢`** (turnstile): Shows the current goal we need to prove
- **`trivial`**: A tactic that proves obviously true statements

## Understanding Lean's Tactic Mode

In tactic mode, you work with a **tactic state** that shows:
1. **Hypotheses**: What you're given (assumptions, previously proven facts)
2. **Goal**: What you need to prove (shown after `⊢`)

**Tactics** are commands that transform the tactic state, moving you closer to completing the proof. Think of them as tools that help you manipulate logical statements.

Important: If you ever find yourself trying to prove `False`, you've likely made an error in your definitions or reasoning. The `sorry` tactic can close any goal by essentially saying "trust me" — useful for incomplete proofs but dangerous if overused!

## Basic Proof Techniques

Here are fundamental examples building up to more complex proofs:

```lean
-- This example claims that P (the conclusion) is true.
-- The hypothesis states that P is true
example (p : Prop) (h : p) : p := by
  exact h
-- this is the probably the easiest thing to prove
-- the conclusion is given to you in the hypothesis gives the conclusion

-- lean has a shorthand tactic to use when a hypothesis
-- gives the current goal
example (p : Prop) (h : p) : p := by
  assumption
```

## Introducing Conjunctions

When we combine two propositions P and Q with "and," we create a **conjunction** written as `P ∧ Q`. This conjunction is true only when both P and Q are true.

### Proving Conjunctions

To prove a conjunction, we must prove both parts:

```lean
-- When you combine two propositions P, Q to create another 
-- proposition P ∧ Q, we call this new proposition the conjunction of P and Q.
--
-- P ∧ Q evaluates to true if both P and Q are true statements.
--
-- In Lean, we use the constructor tactic to take the goal
-- and break the conjunction into subgoals. Each subgoal requires a proof.
-- A dot (· (`\.`)) is used to specify the proof for that subgoal.
-- There are two cases since the conjunction has two propositions.
example (p q : Prop) (h1 : p) (h2 : q) : p ∧ q := by
  -- p q : Prop
  -- h1 : p
  -- h2 : q
  -- ⊢ p ∧ q
  constructor
  · -- ⊢ p
    exact h1
  · -- ⊢ q
    exact h2
```

The `constructor` tactic breaks the conjunction goal into two subgoals. The dot notation (`·`) focuses on each subgoal individually.

### Using Conjunctions

When you have a conjunction as a hypothesis, you can extract its components:

```lean
-- Given a conjunction (h : p ∧ q), conclude p 

-- One way to approach this is to introduce a new intermediate hypothesis.
-- The `have` tactic is used to create a new hypothesis labeled by hp.

-- hp is defined (:=) by the expression h.1. This dot notation is used to select
-- p from the conjunction h. Similarly h.2 can be used to select q from the conjunction.
example (p q : Prop) (h : p ∧ q) : p := by
  -- h : p ∧ q
  -- ⊢ p
  have hp := h.1
  -- h : p ∧ q
  -- hp : p
  -- ⊢ p
  exact hp

-- the propositions in the hypothesis h can also be referenced by left/right.
example (p q : Prop) (h : p ∧ q) : q := by
  -- p q : Prop
  -- h : p ∧ q
  -- ⊢ q
  have hq := h.right
  -- h : p ∧ q
  -- hq : q
  -- ⊢ q
  exact hq

-- the goal can be closed more directly using the `exact` tactic.
example (p q : Prop) (h : p ∧ q) : q := by
  -- p q : Prop
  -- h : p ∧ q
  -- ⊢ q
  exact h.right
```

You can access conjunction components using:
- `h.1` and `h.2` (numbered access)
- `h.left` and `h.right` (named access)

### Advanced Techniques: Deconstructing Conjunctions

The `cases` tactic provides another way to work with conjunctions:

```lean  
-- Next we show that conjunction is commutative
example (p q : Prop) (h : p ∧ q) : q ∧ p := by
  -- p q : Prop
  -- h : p ∧ q
  -- ⊢ q ∧ p
  cases h with
  | intro hp hq => -- introduce the propositions as hp and hq resp.
    -- hp : p
    -- hq : q
    -- ⊢ q ∧ p
    constructor
    · -- ⊢ q
      exact hq
    · -- ⊢ p
      exact hp
```

This approach deconstructs the conjunction hypothesis into separate named hypotheses.

## Working with Multiple Conjunctions

Conjunctions with more than two propositions associate to the right: `p ∧ q ∧ r` means `p ∧ (q ∧ r)`.

```lean
-- When there are more than two propositions joined in a conjunction,
-- the constructor tactic can be used twice. The sub-goals depend on 
-- how the terms are associated. With no explicit parentheses,
-- the parentheses group the right-most: p ∧ q ∧ r = p ∧ (q ∧ r).

-- Note that the dots are still needed to focus which tactic solves which subgoal
-- Also note that all the proofs of the subgoals needed a ⬝ except the constructor tactic
theorem p4 (p q r : Prop) (h1 : p) (h2 : q) (h3 : r) : p ∧ q ∧ r := by
  -- h1 : p
  -- h2 : q
  -- h3 : r
  -- ⊢ p ∧ q ∧ r
  constructor --break the goal into two subgoals
  · -- ⊢ p
    exact h1 -- prove the first case (the one above)
  · -- ⊢ q ∧ r
    constructor -- break the second goal further into subgoals ( the one below)
    · -- ⊢ q
      exact h2
    · -- ⊢ r
      exact h3
```

## The Art of Mathematical Proof
Picture yourself standing at the edge of an unfamiliar city, holding a crumpled map and squinting at street signs written in a language you're still learning. This is what it can feel like to begin a mathematical proof.

Your destination shimmers in the distance—that elegant statement marked with the turnstile symbol `⊢`. It might be something deceptively simple, or it could be something that's haunted mathematicians for centuries, lurking just beyond.

Each hypothesis in your toolkit — whether it's a well-established theorem, a proven lemma, or a given proposition — is like a city on your map, a stable landmark you can rely on. These are the places you know exist, the solid ground from which you can launch your next move. The tactics? They're your highways — well-paved routes like `constructor` that reliably connect one city to another, or swift expressways like `exact` that can shoot you directly from hypothesis to goal when the connection is clear.

The mathematical landscape is beautiful. Alive and growing. As vast as the universe itself. Every time a mathematician proves a new theorem, they're not just reaching a destination — they're founding a new city on the map, creating a reliable landmark that future explorers can use as a waystation for even grander journeys.

And who knows? The path you build today might be exactly the one that tomorrow's mathematical adventurer needs to reach a destination we can't even imagine yet.

## Practice Problems

Try proving these examples yourself:

```lean
example (p q : Prop) (h : q) : (q ∧ q) := by 
  sorry

example (p q : Prop) (h : p ∧ q) : (p ∧ q) ∧ q := by 
  sorry

example (p q : Prop) (h1 : p) (h2 : q) : (p ∧ q) ∧ p := by 
  sorry

example (p q : Prop) (h1 : p ∧ p) (h2 : q) : (p ∧ q) ∧ p := by 
  sorry

example (p q r : Prop) (h : p ∧ q ∧ r) : p ∧ r := by
  sorry
```

These exercises will help you practice the fundamental techniques of constructing and deconstructing conjunctions. Remember: start with the goal, identify what you need to prove, and use the tools (tactics) and materials (hypotheses) available to build your proof step by step.