---
title: 'Quantifiers: Part 1'
date: 2025-10-08
permalink: /posts/2025/10/blog-post-7/
tags:
  - lean
  - logic
  - quantifiers
  - exists
---

In our `Propositions` series we have covered `Prop`, compound expressions of propositions (conjunction, disjunction, exclusive-or, implication, bi-implication, negation), and rules for how to prove them. In this next series on quantifiers, we will learn what they are and how to prove statements involving them.

Quantifiers allow us to express statements such as:
- There exists a number x that satisifes a certain property. 
- There is a unique s that satisfies a ceratin property.
- For all elements in the set, each satisfies a property.

```lean
--    Universal: ∀ x, P(x)
--    Existential: ∃ x, P(x)
```

```lean
-- we can consider general properties of natural numbers P Q
-- we define global variables P Q to use them in our theorems:
variable (P : ℕ → Prop) -- some arbitrary predicate about ℕ
variable (Q : ℕ → Prop) -- another one

example (h : ∀ x, P x → Q x) (hp : P 3) : Q 3 := by
  apply h 3 -- apply is applied at the goal to give
  exact hp

-- here, we are focused on proving general results
-- we will keep using ℕ as our natural domain

-- Forward implications with ∀
-- If you have an instance of ℕ, you can use it as an argument to →
-- The hypotheses give you an arbitrary n ∈ ℕ and that P n is true
theorem p41 (h : ∀ x, P x → Q x) (n : ℕ) (hp : P n) : Q n := by
  have f_n := h n   -- instantiate predicate with n: P n → Q n
  exact f_n hp      -- modus ponens to derive Q n


-- Use intro tactic to instantiate a variable in a ∀ statement
theorem p43 : ∀x, P x → P x := by
  intro a  -- Let a ∈ ℕ (arbitrary)
  tauto -- now that it is instantiated with a concrete value,
        -- you can just treat it as a proposition

-- another way to express this
theorem p44 : ∀x, P x → P x := by
  intro b  -- let b ∈ ℕ (arbitrary). Then we show P b → P b
  intro pb -- Suppose P b
  exact pb -- Then P b

-- commutativity of ∃ over ∧: false start
--
--theorem p46a (h : ∃ x, P x ∧ Q x) : (∃ x, P x) ∧ (∃ x, Q x) := by
--  constructor     -- show (∃x P x) in case 1 and (∃x Q x) in case 2
--  · exact h.left  -- this won't work because of unbound variable
--  · exact h.right -- the hypothesis is a function over a conjunction
                    -- not simply a conjunction

theorem p47 (h : ∀ x, P x ∧ Q x) : (∀ x, P x) ∧ (∀ x, Q x) := by
  constructor
  · intro n; exact (h n).left -- you don't need to use have tactic
  · intro n; have pq := h n   -- but you can use it, stylistic choice
    exact pq.right

theorem p48 (h : (∀ x, P x) ∧ (∀ x, Q x)) : ∀ x, P x ∧ Q x := by
  intro n  -- let n ∈ ℕ, show P n ∧ Q n
  constructor
  · have pn := h.left n; exact pn  -- derive P n
  · have qn := h.right n; exact qn -- derive Q n


-- contrapositive with ∀ and ¬
theorem p51 (h : ∀ x, P x → Q x) : ∀ x, ¬Q x → ¬P x := by
  intro a nqa
  have pqa := h a
  by_contra pa
  have qa := pqa pa
  contradiction

-- alternative
theorem p52 (h : ∀ x, P x → Q x) : ∀ x, ¬Q x → ¬P x := by
  intro a nqa     -- let a ∈ ℕ s.t. ¬Q a
  intro pa        -- ¬P a ↔ P a → False (by way of contradiction assume P a)
  apply nqa       -- show Q a
  exact h a pa

--∀ distributes over ∧
theorem p53 (h : ∀ x, P x ∧ Q x) : (∀ x, P x) ∧ (∀ x, Q x) := by
  constructor            --Show ∀x Px
  · intro a              --  Let a ∈ ℕ (arbitrary)
    exact (h a).left     --  use hypothesis on a, derive P a
  · intro b              --Show ∀x Qx
                         --  Let n ∈ ℕ (arbitrary)
    have hb := h b       --  use hypothesis with b
    exact hb.right       -- derive Q b

-- implication with case split on assumption
theorem p54 (h : ∀ x, ¬P x ∨ Q x) (n : ℕ) (px : P n) : Q n := by
  have hpq := h n   -- suppose n s.t. ¬P n ∨ Q n
  cases hpq with
  |inl np =>        -- suppose ¬P n
  contradiction     -- this leads to a contradiction so P n
  |inr qp =>        -- suppose Q n
  exact qp

theorem p55 (h : ∀ x, P x → Q x) (hp : ∀ x, P x) : ∀ x, Q x := by
  intro a          -- let a ∈ ℕ
  have hpa := hp a -- then P a by hp
  have hpqa := h a -- then P a → Q a by h a
  exact hpqa hpa   -- modus ponens to derive Q a

```