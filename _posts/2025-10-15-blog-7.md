---
title: 'Universal Quantification'
date: 2025-10-18
permalink: /posts/2025/10/blog-post-7/
tags:
  - lean
  - logic
  - quantifiers
  - forall
---

In our `Propositions` series we have covered `Prop`, compound expressions of propositions (conjunction, disjunction, exclusive-or, implication, bi-implication, negation), and rules for how to prove them. In this next series on quantifiers, we will learn about quantification and prove statements involving them.

Quantifiers allow us to express statements such as:
- "Every complex number has a square root."
- "There is a unique integer that divides every even number."
- "Every integer is either even or odd."

Universal quantifiers deal with propositions that make use of "for all" or "every". These are propositions that want to claim something about all the objects of interest. In mathematics, these objects of interest are usually elements of a set.

Symbolically, universal quantification is denoted with the symbol `∀`. Typically, these propositions are of the form `∀x, P(x)` where `x` is an arbitrary object of interest and `P` is a logical proposition about elements like `x`. 

Let's define some symbols for propositions that we will use. For this series, we will prove general forms of propositions of natural numbers. We define global variables `P` `Q` which are predicates about natural numbers.

```lean
variable (P : ℕ → Prop)
variable (Q : ℕ → Prop)
```

If we inspect the type of the variable, we see:
```lean
#check P
⊢ ℕ → Prop
```

In Lean, this type is a function from natural numbers to propositions. An instance of `P` could be "Even(n)" where `n` is a natural number. "Even(n)" is a propostion that is true iff `n` is even and false otherwise. We'll look at more mathematical instances of `P` in future posts.

The Universal quantifier has a bound variable `x`. 
To prove a statement that has universal quantification, we have to let `x` be an arbitrary element of some set.
 
```lean
example (h : ∀ x, P x → Q x) (hp : P 3) : Q 3 := by
  apply h 3 -- apply is applied at the goal to give
  exact hp

-- here, we are focused on proving general results
-- we will keep using ℕ as our natural domain

-- Forward implications with ∀
-- If you have an instance of ℕ, you can use it as an argument to →
-- The hypotheses give you an arbitrary n ∈ ℕ and that P n is true
theorem p41 (h : ∀ x, P x → Q x) (n : ℕ) (hp : P n) : Q n := by
  have f_n := h n   -- instantiate predicate with n: P n → Q n
  exact f_n hp      -- modus ponens to derive Q n


-- Use intro tactic to instantiate a variable in a ∀ statement
theorem p43 : ∀x, P x → P x := by
  intro a  -- Let a ∈ ℕ (arbitrary)
  tauto -- now that it is instantiated with a concrete value,
        -- you can just treat it as a proposition

-- another way to express this
theorem p44 : ∀x, P x → P x := by
  intro b  -- let b ∈ ℕ (arbitrary). Then we show P b → P b
  intro pb -- Suppose P b
  exact pb -- Then P b

-- commutativity of ∃ over ∧: false start
--
--theorem p46a (h : ∃ x, P x ∧ Q x) : (∃ x, P x) ∧ (∃ x, Q x) := by
--  constructor     -- show (∃x P x) in case 1 and (∃x Q x) in case 2
--  · exact h.left  -- this won't work because of unbound variable
--  · exact h.right -- the hypothesis is a function over a conjunction
                    -- not simply a conjunction

theorem p47 (h : ∀ x, P x ∧ Q x) : (∀ x, P x) ∧ (∀ x, Q x) := by
  constructor
  · intro n; exact (h n).left -- you don't need to use have tactic
  · intro n; have pq := h n   -- but you can use it, stylistic choice
    exact pq.right

example (h : (∀ x, P x) ∧ (∀ x, Q x)) : ∀ x, P x ∧ Q x := by
  -- ⊢ ∀ (x : ℕ), P x ∧ Q x
  intro n                  -- let n ∈ ℕ
  -- n : ℕ
  -- ⊢ P n ∧ Q n           -- show P(n) and Q(n)
  constructor
  · -- ⊢ P n               -- first, we show P(n)
    have pn := h.left n    -- we know from our hypothesis ∀(x : ℕ), P(x)
                           -- in particular, the n we introduced is a natural number    
    -- pn : P n
    exact pn               -- hence P(n)

  · -- ⊢ Q n               -- next, we show Q(n)
    have qn := h.right n   -- ∀(x : ℕ), Q(x) follows from our hypothesis
                           -- in particular, n is a natural number
    -- qn : Q n
    exact qn               -- hence Q(n)



-- contrapositive with ∀ and ¬
theorem p51 (h : ∀ x, P x → Q x) : ∀ x, ¬Q x → ¬P x := by
  intro a nqa
  have pqa := h a
  by_contra pa
  have qa := pqa pa
  contradiction

-- alternative
theorem p52 (h : ∀ x, P x → Q x) : ∀ x, ¬Q x → ¬P x := by
  intro a nqa     -- let a ∈ ℕ s.t. ¬Q a
  intro pa        -- ¬P a ↔ P a → False (by way of contradiction assume P a)
  apply nqa       -- show Q a
  exact h a pa

--∀ distributes over ∧
theorem p53 (h : ∀ x, P x ∧ Q x) : (∀ x, P x) ∧ (∀ x, Q x) := by
  constructor            --Show ∀x Px
  · intro a              --  Let a ∈ ℕ (arbitrary)
    exact (h a).left     --  use hypothesis on a, derive P a
  · intro b              --Show ∀x Qx
                         --  Let n ∈ ℕ (arbitrary)
    have hb := h b       --  use hypothesis with b
    exact hb.right       -- derive Q b

-- implication with case split on assumption
theorem p54 (h : ∀ x, ¬P x ∨ Q x) (n : ℕ) (px : P n) : Q n := by
  have hpq := h n   -- suppose n s.t. ¬P n ∨ Q n
  cases hpq with
  |inl np =>        -- suppose ¬P n
  contradiction     -- this leads to a contradiction so P n
  |inr qp =>        -- suppose Q n
  exact qp

theorem p55 (h : ∀ x, P x → Q x) (hp : ∀ x, P x) : ∀ x, Q x := by
  intro a          -- let a ∈ ℕ
  have hpa := hp a -- then P a by hp
  have hpqa := h a -- then P a → Q a by h a
  exact hpqa hpa   -- modus ponens to derive Q a

```