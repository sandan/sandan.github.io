---
title: 'Universal Quantification'
date: 2025-10-18
permalink: /posts/2025/10/blog-post-7/
tags:
  - lean
  - logic
  - quantifiers
  - forall
---

In our `Propositions` series we have covered `Prop`, compound expressions of propositions (conjunction, disjunction, exclusive-or, implication, bi-implication, negation), and rules for how to prove them. In this next series on quantifiers, we will learn about quantification and prove statements involving them.

Quantifiers allow us to express statements such as:
- "Every complex number has a square root."
- "There is a unique integer that divides every even number."
- "Every integer is either even or odd."

Universal quantifiers deal with propositions that make use of "for all", "each thing", "anything" or "everything". These are propositions that want to claim something about all the objects of interest. In mathematics, these objects of interest are usually elements of a set.

Symbolically, universal quantification is denoted with the symbol `∀`. Typically, these propositions are of the form `∀x, P(x)` where `x` is an arbitrary object of interest and `P` is a logical proposition about elements like `x`. 

Let's define some symbols for propositions that we will use. For this series, we will prove general forms of propositions of natural numbers. We define global variables `P` `Q` which are predicates about natural numbers.

```lean
variable (P : ℕ → Prop)
variable (Q : ℕ → Prop)
```

If we inspect the type of the variable, we see:
```lean
#check P
⊢ ℕ → Prop
```

In Lean, this type is a function from natural numbers to propositions. An instance of `P` could be "Even(n)" where `n` is a natural number. "Even(n)" is a propostion that is true iff `n` is even and false otherwise. We'll look at more mathematical instances of `P` in future posts.

The Universal quantifier has a bound variable `x`. 
To prove a statement that has universal quantification, we have to let `x` be an arbitrary element of some set. In Lean, we use the `intro` tactic to instantiate a variable when a universal proposition is in the goal (`∀` proposition).

Let's look at a first example: 
```lean
example : ∀x, P x → P x := by
  -- ⊢ ∀ (x : ℕ), P x → P x
  intro b                    -- let b ∈ ℕ (arbitrary). 
  -- ⊢ P b → P b
  intro pb                   -- Suppose P b
  -- pb : P b
  -- ⊢ P b
  exact pb                   -- Then P b
```
You may remember the example `p → p` in our post about implication. We learned that the `tauto` tactic can be used to prove this. The `tauto` tactic can also be used in quantified propositions: 
```lean
-- another way to express this
theorem p43 : ∀x, P x → P x := by
  -- ⊢ ∀ (x : ℕ), P x → P x
  tauto
```

What if we have a hypothesis that uses quantified propositions?
```lean
example (h : ∀ x, P x → Q x) (hp : P 3) : Q 3 := by
  -- ⊢ Q 3    -- showing the goal Q(3)
  apply h     -- reduces to showing P(3)
  -- ⊢ P 3
  exact hp    -- we know this from our hypothesis
```
Let's take a closer look at our hypothesis in the previous proof:
```lean
variable (h₁ : ∀ x, P x → Q x)
```
This variable looks like implication. In the function interpretation of implication, we can pass arguments to it to obtain the consequent. Let's pass a natural number:
```lean
#check h₁   -- ⊢ ∀ (x : ℕ), P x → Q x
#check h₁ 0 -- ⊢ P 0 → Q 0
```
When we pass 0 to the statement `h₁`, the quantifier is removed and we get an implication -- just like the ones we worked with in our Propositions series. This makes sense since `P` and `Q` both return `Prop`:
```lean
#check P 0 -- P 0 : Prop
#check Q 0 -- Q 0 : Prop
```

Let's look at using this in practice:
```lean
-- The hypotheses give you an arbitrary n ∈ ℕ and that P n is true
example (h : ∀ x, P x → Q x) (n : ℕ) (hp : P n) : Q n := by
  -- ⊢ Q n
  have f3 := h 3   -- We can use a particular natural number (3)
  -- f3 : P 3 → Q 3
                   -- but the goal requires an arbitrary natural number n
  have fn := h n   -- Instead, we use n in our hypothesis
  -- fn : P n → Q n
  exact fn hp      -- modus ponens to derive Q n
```

```lean
theorem p47 (h : ∀ x, P x ∧ Q x) : (∀ x, P x) ∧ (∀ x, Q x) := by
  constructor
  · intro n; exact (h n).left -- you don't need to use have tactic
  · intro n; have pq := h n   -- but you can use it, stylistic choice
    exact pq.right

example (h : (∀ x, P x) ∧ (∀ x, Q x)) : ∀ x, P x ∧ Q x := by
  -- ⊢ ∀ (x : ℕ), P x ∧ Q x
  intro n                  -- let n ∈ ℕ
  -- n : ℕ
  -- ⊢ P n ∧ Q n           -- show P(n) and Q(n)
  constructor
  · -- ⊢ P n               -- first, we show P(n)
    have pn := h.left n    -- we know from our hypothesis ∀(x : ℕ), P(x)
                           -- in particular, the n we introduced is a natural number    
    -- pn : P n
    exact pn               -- hence P(n)

  · -- ⊢ Q n               -- next, we show Q(n)
    have qn := h.right n   -- ∀(x : ℕ), Q(x) follows from our hypothesis
                           -- in particular, n is a natural number
    -- qn : Q n
    exact qn               -- hence Q(n)



-- contrapositive with ∀ and ¬
theorem p51 (h : ∀ x, P x → Q x) : ∀ x, ¬Q x → ¬P x := by
  intro a nqa
  have pqa := h a
  by_contra pa
  have qa := pqa pa
  contradiction

-- alternative
theorem p52 (h : ∀ x, P x → Q x) : ∀ x, ¬Q x → ¬P x := by
  intro a nqa     -- let a ∈ ℕ s.t. ¬Q a
  intro pa        -- ¬P a ↔ P a → False (by way of contradiction assume P a)
  apply nqa       -- show Q a
  exact h a pa

--∀ distributes over ∧
theorem p53 (h : ∀ x, P x ∧ Q x) : (∀ x, P x) ∧ (∀ x, Q x) := by
  constructor            --Show ∀x Px
  · intro a              --  Let a ∈ ℕ (arbitrary)
    exact (h a).left     --  use hypothesis on a, derive P a
  · intro b              --Show ∀x Qx
                         --  Let n ∈ ℕ (arbitrary)
    have hb := h b       --  use hypothesis with b
    exact hb.right       -- derive Q b

-- implication with case split on assumption
theorem p54 (h : ∀ x, ¬P x ∨ Q x) (n : ℕ) (px : P n) : Q n := by
  have hpq := h n   -- suppose n s.t. ¬P n ∨ Q n
  cases hpq with
  |inl np =>        -- suppose ¬P n
  contradiction     -- this leads to a contradiction so P n
  |inr qp =>        -- suppose Q n
  exact qp

theorem p55 (h : ∀ x, P x → Q x) (hp : ∀ x, P x) : ∀ x, Q x := by
  intro a          -- let a ∈ ℕ
  have hpa := hp a -- then P a by hp
  have hpqa := h a -- then P a → Q a by h a
  exact hpqa hpa   -- modus ponens to derive Q a

```