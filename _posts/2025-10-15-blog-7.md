---
title: 'Universal Quantification'
date: 2025-10-20
permalink: /posts/2025/10/blog-post-7/
tags:
  - lean
  - logic
  - quantifiers
  - forall
---

In our `Propositions` series we have covered `Prop`, compound expressions of propositions (conjunction, disjunction, exclusive-or, implication, bi-implication, negation), and rules for how to prove them. In this next series on quantifiers, we will learn about quantification and prove statements involving them.

Quantifiers allow us to express statements such as:
- "Every complex number has a square root."
- "There is a unique integer that divides every even number."
- "Every integer is either even or odd."

Quantifiers can be used with all the compound propositions. When a proposition is quantified, its truth depends on the a variable. We begin with the universal quantifier.

Universal quantifiers deal with propositions that make use of "for all", "each thing", "anything" or "everything". These are propositions that want to claim something about all the objects of interest. In mathematics, these objects of interest are usually elements of a set.

Symbolically, universal quantification is denoted with the symbol `∀`. Typically, these propositions are of the form `∀x, P(x)` where `x` is an arbitrary object of interest and `P` is a logical proposition about elements like `x`. 

Let's define some symbols for propositions that we will use. For this series, we will prove general forms of propositions of natural numbers. We define global variables `P` `Q` which are predicates about natural numbers.

```lean
variable (P : ℕ → Prop)
variable (Q : ℕ → Prop)
```

If we inspect the type of the variable, we see:
```lean
#check P
⊢ ℕ → Prop
```

In Lean, this type is a function from natural numbers to propositions. An instance of `P` could be "Even(n)" where `n` is a natural number. "Even(n)" is a propostion that is true iff `n` is even and false otherwise. We'll look at more mathematical instances of `P` in future posts.

The Universal quantifier has a bound variable `x`. 
To prove a statement that has universal quantification, we have to let `x` be an arbitrary element of the set. In Lean, we use the `intro` tactic to instantiate a variable when a universal proposition is in the goal (`∀` proposition).

Let's look at a first example. You may remember the example `p → p` in our post about implication. This example is just like that but now the propositions use a universal quantifier and a bound variable `x`: 
```lean
example : ∀x, P x → P x := by 
  -- ⊢ ∀ (x : ℕ), P x → P x
  intro b                    -- let b ∈ ℕ (arbitrary). 
  -- b : ℕ
  -- ⊢ P b → P b
  intro pb                   -- Suppose P b
  -- pb : P b
  -- ⊢ P b
  exact pb                   -- Then P b
```
We had to use the `intro` tactic twice! Once to remove the quantifier in the goal and again to obtain the hypothesis (`pb : P b`). 

The previous example states that: "for all natural numbers, `P x` implies `P x`". If it is true for all natural numbers, we should be able to choose any particular natural number and the resulting statement ("`P x` implies `P x`) should hold. 

The first `intro` is doing that. The first `intro` is choosing an arbitrary natural number and calling it `b` which introduces a new hypothesis (`b : ℕ`) in the proof state. Once we have this arbitrary natural number to work with, we no longer need the universal quantifier. 

 We learned that the `tauto` tactic can be used to prove this. The `tauto` tactic can also be used in quantified propositions: 
```lean
-- another way to express this
theorem p43 : ∀x, P x → P x := by
  -- ⊢ ∀ (x : ℕ), P x → P x
  tauto
```

What if we have a hypothesis that uses quantified propositions?
```lean
example (h : ∀ x, P x → Q x) (hp : P 3) : Q 3 := by
  -- ⊢ Q 3      
  have k := h 3 -- use a particular value (3) for the universal quantifiers variable
  -- k : P 3 → Q 3 
  exact k hp    -- but we know P 3 from our hypothesis

```

Let's take a closer look at our hypothesis in the previous proof:
```lean
variable (h₁ : ∀ x, P x → Q x)
```
The variable `h₁` looks like implication. In the function interpretation of implication, we can pass arguments to obtain the consequent. Let's pass a natural number:
```lean
#check h₁   -- ⊢ ∀ (x : ℕ), P x → Q x
#check h₁ 0 -- ⊢ P 0 → Q 0
```
When we pass 0 to the statement `h₁`, the quantifier is removed and we get an ordinary proposition about implication -- just like the ones we worked with in our Propositions series. This makes sense since `P` and `Q` both return `Prop` when given a natural number:
```lean
#check P 0 -- P 0 : Prop
#check Q 0 -- Q 0 : Prop
```

Another way to to prove the result in the previous example is to use the `apply` tactic. The tactic works backwards from the goal using the hypothesis. We've seen this used a lot in the post about implication. 

```lean
example (h : ∀ x, P x → Q x) (hp : P 3) : Q 3 := by
  -- ⊢ Q 3
  apply h     -- reduces to showing P 3
  -- ⊢ P 3
  exact hp    -- we know this from our hypothesis
```
In this case, the goal has a particular natural number but the hypothesis has a universal quantifier. Even though the goal uses a particular value, the `apply` tactic is smart enough to know that since `h` uses a universal quantifier, `3` works just as well as any other natural number.

Let's look at a related but more general example:
```lean
-- The hypotheses give you an arbitrary n ∈ ℕ and that P n is true
example (h : ∀ x, P x → Q x) (n : ℕ) (hp : P n) : Q n := by
  -- ⊢ Q n
  have f3 := h 3   -- We can use a particular natural number (3),
  -- f3 : P 3 → Q 3
                   -- but the goal requires an arbitrary natural number n.
  have fn := h n   -- Instead, we use n in our hypothesis
  -- fn : P n → Q n
  exact fn hp      -- modus ponens to derive Q n
```

In the last example, we happened to have a natural number `n`. It was an arbitrary natural number `n`. The universal quantifier was used implicitly. Let's see an example where the quantifiers are made explicit:
```lean
example (h : ∀ x, P x → Q x) (hp : ∀ x, P x) : ∀ x, Q x := by
  intro a          -- let a ∈ ℕ
  -- a : ℕ
  have hpa := hp a -- then P a by hp
  -- hpa : P a
  have hpqa := h a -- then P a → Q a by h a
  -- hpqa : P a → Q a
  exact hpqa hpa   -- modus ponens to derive Q a
```

Now, let's take a look at how the univeral quantifier works with conjunctions. In the next example, we show that the universal quantifier can distribute over conjunction. 
```lean
example (h : ∀ x, P x ∧ Q x) : (∀ x, P x) ∧ (∀ y, Q y) := by
  -- ⊢ (∀ (x : ℕ), P x) ∧ ∀ (y : ℕ), Q y
  constructor             -- We show that ∀ distributes across ∧.
  · -- ⊢ ∀ (x : ℕ), P x  -- First, we show ∀x, P x.
    intro n               -- Let n be an arbitrary natural number. 
    -- n : ℕ
    -- ⊢ P n              -- We show P n.
    exact (h n).left      -- We know P n ∧ Q n from our hypothesis!
                          -- In particular, the left conjunct is our conclusion.

  · -- ⊢ ∀ (y : ℕ), Q y  -- Now, we show ∀y, Q y.
    intro n               -- Let n be an arbitrary natural number.
    -- n : ℕ
    have pq := h n        -- Instantiate our hypothesis with natural number n.
    -- pq : P n ∧ Q n     -- This removes the quantifier and gives a conjunction using n!
    -- ⊢ Q n
    exact pq.right        -- The right conjunct is the goal.
```
Note that the bound variables in the goal are different (x for P and y for Q). Technically, we could have used the same variable and the proof and meaning would remain the same. This is because the variable names in universal quantification are just placeholders: each quantifier introduces a new scope, so using different names or the same name does not affect the logic or outcome of the proof, as long as the variables are properly scoped. 

In Lean, scoping affects when certain tactics can be used. In the proof, we used the `intro` tactic in each case of `constructor`. We cannot use it before the `constructor` because the quantifier in the goal applies separately to each conjunct in the conjunction. Each conjunct introduces its own universal quantifier, so we must introduce a variable for each conjunct individually after splitting the goal with `constructor`. If the scope of the quantifier applies to the same variable shared with P and Q in the conjunction, then we can instantiate an arbitrary `n`. Let's have a look:

```lean
example (h : (∀ x, P x) ∧ (∀ y, Q y)) : ∀ x, P x ∧ Q x := by
  -- ⊢ ∀ (x : ℕ), P x ∧ Q x
  intro n                  -- let n ∈ ℕ
  -- n : ℕ
  -- ⊢ P n ∧ Q n           -- show P(n) and Q(n)
  constructor
  · -- ⊢ P n               -- first, we show P(n)
    have pn := h.left n    -- we know from our hypothesis ∀(x : ℕ), P(x)
                           -- in particular, the n we introduced is a natural number    
    -- pn : P n
    exact pn               -- hence P(n)

  · -- ⊢ Q n               -- next, we show Q(n)
    have qn := h.right n   -- ∀(y : ℕ), Q(y) follows from our hypothesis
                           -- in particular, n is a natural number
    -- qn : Q n
    exact qn               -- hence Q(n)
```

In the post about implication, we learned that the *contrapositive* of the implication "`if p then q`" is the implication "`if not q then not p`". The universal quantifier does not change this equivalence.

```lean
-- contrapositive with ∀ and ¬
example (h : ∀ x, P x → Q x) : ∀ x, ¬Q x → ¬P x := by
  -- ⊢ ∀ (x : ℕ), ¬Q x → ¬P x
  intro a nqa              -- Let "a" be an arbitrary natural number.
  -- a : ℕ                 -- Assume the negation of Q a.
  -- nqa : ¬Q a
  -- ⊢ ¬P a                -- We show the negatiof of P a.
  have pqa := h a          -- Use our arbitrary natural number "a".
  -- pqa : P a → Q a 
  -- ⊢ ¬P a
  by_contra pa             -- Assume by way of contradiction, P a holds.
  -- pa : P a
  -- ⊢ False              -- Then we will show this leads to a Falsehood.
  have qa := pqa pa       -- We use modus ponens to deduce Q a
  -- qa : Q a
  -- ⊢ False
  contradiction           -- This contradicts our hypotheses nqa and qa.
```

Another style of proving this uses the interpretation of negation as an implicaiton of Falsehood. This gives us a more direct proof that should look more familiar:
```lean
-- alternative
example (h : ∀ x, P x → Q x) : ∀ x, ¬Q x → ¬P x := by
  -- ⊢  (x : ℕ), ¬Q x → ¬P x
  intro a nqa     -- let a ∈ ℕ s.t. ¬Q a
  -- a : ℕ
  -- nqa : ¬Q a
  -- ⊢ ¬P a
  intro pa        -- ¬P a ↔ P a → False (by way of contradiction assume P a)
  -- pa : P a
  -- ⊢ False
  apply nqa       -- show Q a
  -- ⊢ Q a
  exact h a pa

```

Let's have a look at universal quantification applied to a disjunction. In this case, we have a hypothesis that has a quantified disjunction:
```lean
example (h : ∀ x, ¬P x ∨ Q x) (n : ℕ) (p : P n) : Q n := by
  -- ⊢ Q n
  have hpq := h n   -- We have n, an arbitrary natural number.
  -- hpq : ¬P n ∨ Q n
  cases hpq with
  | inl np =>       -- Suppose ¬P n,
  -- np : ¬P n
  -- p  : P n
  contradiction     -- this leads to a contradiction.
  | inr qp =>       -- Suppose Q n.
  -- qp : Q n
  exact qp          -- this case is exactly our goal.
```

# Exercises
1. Simple instantiation (very easy)
```lean
example (h : ∀ x, P x) : P 5 := by
  -- hint: remove the quantifier by supplying 5 to h
```

2. Add a disjunct to a universally true predicate (easy)
```lean
example (h : ∀ x, P x) : ∀ x, P x ∨ Q x := by
  -- hint: introduce an arbitrary n, then use `left` with `h n`
```

3. Extract a global proposition from universally quantified implications (medium)
```lean
example (R : Prop) (h : ∀ x, P x → R) (hp : ∀ x, P x) : R := by
  -- hint: pick any natural number n, use h n : P n → R and hp n : P n
```

4. Combine a pointwise implication with a pointwise disjunction (medium)
```lean
example (h1 : ∀ x, P x → Q x) (h2 : ∀ x, P x ∨ Q x) : ∀ x, Q x := by
  -- hint: for arbitrary n, examine `h2 n` with `cases`; in the `P n` case use `h1 n`
```

5. Build a pointwise conjunction from two universal facts (medium)
```lean
example (hP : ∀ x, P x) (hQ : ∀ x, Q x) : ∀ x, P x ∧ Q x := by
  -- hint: introduce n, then use `constructor` and apply `hP n` and `hQ n`
```

Optional challenge (use negation + introduction by contradiction). We haven't looked at existential quantification yet. Feel free to come back to this after reading about it in the next post!
6. No counterexample to pointwise implication (harder)
```lean
example (h : ∀ x, P x → Q x) : ¬ (∃ n, P n ∧ ¬ Q n) := by
  -- hint: assume the existence of a witness, `cases` it, and derive a contradiction
  -- (this uses `by_contra` / `intro` + `cases` + `exact` / `contradiction`)
```
