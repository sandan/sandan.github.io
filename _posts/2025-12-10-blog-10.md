---
title: 'Mixed Quantifiers'
date: 2025-11-24
permalink: /posts/2025/11/blog-post-10/
tags:
  - lean
  - logic
  - forall
  - exists
  - mixed quantifiers
---

When you first encounter formal logic, single quantifiers like "for all x" (∀) or "there exists x" (∃) feel manageable. However, mathematics is often about the relationship between two variables. 

- For any two vertices, an edge can be constructed by joining those vertices.

- There is a constant for every circle of radius r that relates the raidus to the circumference of a circle.

- There exists integers `x` and `y` such that `x > 0 > y`.

- For any two integers `x` and `y`, if `x != y` then `| x- y | > 0`.

Mixed quantification can help make these relationships precise.

## What Are Mixed Quantifiers?

Mixed quantifiers are logical statements that combine both universal (∀) and existential (∃) quantifiers. The order matters enormously!

Consider these two statements:
- **Statement A**: ∀ x, ∃ y, y > x (For every number x, there exists a number y greater than x)
- **Statement B**: ∃ y, ∀ x, y > x (There exists a number y greater than every number x)

Statement A is true for natural numbers—you can always find a bigger number. Statement B is false—no single number is bigger than all numbers. The only difference? The order of quantifiers.

## The Pattern: Reading Quantifiers Left to Right

When you see mixed quantifiers, read them left to right, treating each quantifier as introducing dependencies:

```lean
∀ x, ∃ y, P x y
```

This means: "Given any x, I can find a y (possibly depending on x) such that P x y holds."

```lean
∃ y, ∀ x, P x y
```

This means: "There is a single y that works for every possible x such that P x y holds."

The second is a much stronger claim!

## Proving Statements with Mixed Quantifiers

### Example 1: Proving ∀ x, ∃ y, y > x

Let's prove that for every natural number, there exists a larger one:

```lean
example : ∀ n : ℕ, ∃ m : ℕ, m > n := by
  intro n
  -- n : ℕ
  -- ⊢ ∃ m, m > n
  use n + 1
  -- ⊢ n + 1 > n
  simp
```

**Tactics used:**
- `intro n`: When proving `∀ n, ...`, we introduce an arbitrary n
- `use n + 1`: When proving `∃ m, ...`, we provide a witness (n + 1)
- `omega`: An arithmetic solver that handles linear arithmetic

Notice how the witness m depends on n—that's the key to "∀ ∃" statements.

### Example 2: A False Statement

Can we prove ∃ n, ∀ m, n > m? Let's see what happens:

```lean
example : ∃ n : ℕ, ∀ m : ℕ, n > m := by
  use 0  -- Try to use 0 as our witness
  intro m
  -- Goal: 0 > m for arbitrary m
  -- This is impossible! We're stuck.
  sorry
```

**Why it fails**: We need a single n that's greater than every m, including n itself. No such number exists!

## Working with Assumptions

### Example 3: Using ∀∃ Hypotheses

When you *have* a ∀∃ statement as an assumption, you can specialize it:

```lean
example (h : ∀ x : ℕ, ∃ y : ℕ, y = x + 1) : ∃ y : ℕ, y = 6 := by
  -- h says: for any x, there's a y equal to x + 1
  -- Let's apply this to x = 5
  specialize h 5
  -- Now h : ∃ y, y = 5 + 1
  obtain ⟨y, hy⟩ := h
  -- hy : y = 5 + 1
  use y
```

**Tactics used:**
- `specialize h 5`: Apply the ∀ statement to a specific value
- `obtain ⟨y, hy⟩ := h`: Extract the witness y and proof hy from an existential statement

### Example 4: Using ∃∀ Hypotheses

With ∃∀ statements, you extract a special value that works for everything:

```lean
example (h : ∃ n : ℕ, ∀ m : ℕ, n ≤ m) : ∀ k : ℕ, ∃ n : ℕ, n ≤ k := by
  obtain ⟨n, hn⟩ := h
  -- n : ℕ
  -- hn : ∀ m, n ≤ m
  -- ⊢ ∀ (k : ℕ), ∃ n, n ≤ k
  intro k
  -- k : ℕ
  -- ⊢ ∃ n, n ≤ k
  use n
  -- ⊢ n ≤ k
  exact hn k
```

**What happened**: We extracted n (which must be 0), and it works for any k we choose.

## Common Patterns and Tactics Summary

### For Proving:
- **∀ x, P x**: Use `intro x` to introduce an arbitrary x
- **∃ x, P x**: Use `use <term>` to provide a specific witness
- **∀ x, ∃ y, P x y**: Use `intro x`, then `use <expression involving x>`
- **∃ x, ∀ y, P x y**: Use `use <specific value>`, then `intro y`

### For Using (from hypotheses):
- **h : ∀ x, P x**: Use `specialize h <term>` or apply it directly
- **h : ∃ x, P x**: Use `obtain ⟨x, hx⟩ := h` to extract the witness
- **h : ∀ x, ∃ y, P x y**: First specialize with a value, then obtain the existential
- **h : ∃ x, ∀ y, P x y**: First obtain the special x, then specialize or apply

## A More Complex Example

Let's combine multiple quantifiers and work with implication:

```lean
-- If for every x there's a y > x, and for every y there's a z > y,
-- then for every x there's a z > x
example (h1 : ∀ x : ℕ, ∃ y : ℕ, y > x)
        (h2 : ∀ y : ℕ, ∃ z : ℕ, z > y) :
        ∀ x : ℕ, ∃ z : ℕ, z > x := by
  
  intro x
  -- x : ℕ
  -- ⊢ ∃ z, z > x
  specialize h1 x
  -- h1 : ∃ y, y > x
  obtain ⟨y, hy⟩ := h1
  -- y : ℕ 
  -- hy : y > x
  specialize h2 y
  -- h2 : ∃z, z > y
  obtain ⟨z, hz⟩ := h2
  -- z : ℕ
  -- hz : z > y
  use z
  -- ⊢ z > x
  exact lt_trans hy hz
```

This example chains two ∀∃ statements together using transitivity via the lemma: `lt_trans`:
```lean
lt_trans.{u_1} {α : Type u_1} [Preorder α] {a b c : α} : a < b → b < c → a < c
```

## Exercises

Try these exercises to practice your understanding:

### Exercise 1: Basic Mixed Quantifiers
```lean
-- Prove that for every natural number n, there exists m such that m = 2 * n
example : ∀ n : ℕ, ∃ m : ℕ, m = 2 * n := by
  sorry
```

### Exercise 2: Order Matters
```lean
-- Can you prove this? Why or why not?
example : ∃ m : ℕ, ∀ n : ℕ, m = 2 * n := by
  sorry
```

### Exercise 3: Using Hypotheses
```lean
-- Given a hypothesis with mixed quantifiers, derive a specific instance
example (h : ∀ x : ℕ, ∃ y : ℕ, y = x^2) : ∃ y : ℕ, y = 9 := by
  sorry
```

### Exercise 4: Three Quantifiers
```lean
-- Prove this statement with three quantifiers
example : ∀ a : ℕ, ∃ b : ℕ, ∀ c : ℕ, a + b ≥ c → b ≥ c := by
  sorry
```

### Exercise 5: Chaining (from the complex example)
```lean
-- Complete this transitivity proof
example (h1 : ∀ x : ℕ, ∃ y : ℕ, y > x)
        (h2 : ∀ y : ℕ, ∃ z : ℕ, z > y) :
        ∀ x : ℕ, ∃ z : ℕ, z > x := by
  sorry
```

### Exercise 6: Negation and Quantifiers
```lean
-- This one is trickier: think about what the negation means
example (h : ¬ (∃ x : ℕ, ∀ y : ℕ, x ≥ y)) : ∀ x : ℕ, ∃ y : ℕ, y > x := by
  sorry
```

Mixed quantifiers are everywhere in mathematics: "for every ε > 0, there exists δ > 0 such that..." (continuity), "there exists N such that for all n ≥ N..." (convergence), and countless other definitions. Understanding how to read, prove, and use these statements in Lean will unlock your ability to formalize real mathematics.

The key insight: quantifier order creates dependencies. Always think about what depends on what, and the tactics will flow naturally from that understanding.